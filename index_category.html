<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>BlessingCards128 åˆ†é¡æŠ½ç±¤</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
body {
    background: #fff9e9;
    font-family: "Noto Sans TC", sans-serif;
    text-align: center;
    padding: 20px;
    color: #5a3d00;
}

h1 {
    font-size: 26px;
    margin-bottom: 14px;
    color: #b06b00;
}

/* æŒ‰éˆ• */
.btn {
    background: #f7c86c;
    padding: 12px 22px;
    border-radius: 25px;
    font-size: 18px;
    color: #5a3d00;
    cursor: pointer;
    border: none;
    margin: 6px;
}
.btn:hover { background: #f5b953; }

/* è¼ªç›¤å®¹å™¨ */
#wheelContainer {
    position: relative;
    width: 380px;
    height: 380px;
    margin: 20px auto;
}

#wheelCanvas {
    width: 380px;
    height: 380px;
}

/* æŒ‡é‡ â–¼ */
#wheelPointer {
    position: absolute;
    top: -22px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 40px;
    color: red;
    z-index: 10;
}

#statusText {
    font-size: 20px;
    margin-top: 12px;
    color: #b06b00;
}
</style>
</head>

<body>

<h1>BlessingCards128 åˆ†é¡æŠ½ç±¤</h1>

<button class="btn" onclick="startCategoryDraw()">ğŸ¡ é–‹å§‹æŠ½åˆ†é¡ç¶“å¥</button>
<button class="btn" onclick="goHome()">ğŸ  å›é¦–é </button>
<button class="btn" onclick="exportPDF()">ğŸ“„ æŠ½ç±¤ç´€éŒ„ PDF</button>

<div id="wheelContainer">
    <div id="wheelPointer">â–¼</div>
    <canvas id="wheelCanvas" width="380" height="380"></canvas>
</div>

<div id="statusText">æŒ‰ã€Œé–‹å§‹æŠ½åˆ†é¡ç¶“å¥ã€é–‹å§‹æŠ½ç±¤</div>

<script src="verseRefMap.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script>
/* -------------------------------
   åˆ†é¡æ¸…å–®ï¼ˆ8 ç¨®ï¼‰
------------------------------- */
const categories = [
    "å¹³å®‰èˆ‡ä¿è­·",
    "ä¾›æ‡‰èˆ‡è±ç››",
    "ä¿¡å¿ƒèˆ‡é †æœ",
    "å–œæ¨‚èˆ‡æ„Ÿæ©",
    "ç¦±å‘Šèˆ‡å€šé ",
    "æ„›èˆ‡é¥’æ•",
    "æ‡‰è¨±èˆ‡ç›¼æœ›",
    "ç¥ç¦èˆ‡æ©å…¸"
];

const CENTER = 190;
const RADIUS = 180;

let canvas = document.getElementById("wheelCanvas");
let ctx = canvas.getContext("2d");

/* -------------------------------
   ç•«è¼ªç›¤
------------------------------- */
function drawWheel(items){
    let count = items.length;
    let arc = Math.PI * 2 / count;

    ctx.clearRect(0,0,380,380);

    for(let i=0; i<count; i++){
        ctx.beginPath();
        ctx.fillStyle = (i%2===0 ? "#fde7b5" : "#fcdca0");
        ctx.moveTo(CENTER, CENTER);
        ctx.arc(CENTER, CENTER, RADIUS, arc*i, arc*(i+1));
        ctx.fill();

        /* åˆ†éš”ç·š */
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.save();
        ctx.translate(CENTER, CENTER);
        ctx.rotate(arc*i + arc/2);
        ctx.textAlign = "right";
        ctx.font = "22px Noto Sans TC";
        ctx.fillStyle = "#5a3d00";
        ctx.fillText(items[i], RADIUS-20, 10);
        ctx.restore();
    }
}

/* easing */
function easeOut(t){
    return 1 - Math.pow(1 - t, 3);
}

/* -------------------------------
   è½‰å‹•è¼ªç›¤ï¼ˆ5ç§’ï¼‰
------------------------------- */
function spinWheel(items){
    return new Promise(resolve => {

        let count = items.length;
        let arc = Math.PI * 2 / count;

        let rotation = Math.PI * 10 + Math.random()*Math.PI*4;
        let start = performance.now();

        function animate(now){
            let progress = (now - start) / 5000;
            if(progress > 1) progress = 1;

            let angle = rotation * easeOut(progress);

            ctx.save();
            ctx.clearRect(0,0,380,380);
            ctx.translate(CENTER, CENTER);
            ctx.rotate(angle);
            ctx.translate(-CENTER, -CENTER);
            drawWheel(items);
            ctx.restore();

            if(progress < 1){
                requestAnimationFrame(animate);
            } else {
                let raw = angle % (2*Math.PI);
                let index = Math.floor((count - raw/arc) % count);
                resolve(items[index]);
            }
        }

        requestAnimationFrame(animate);
    });
}

/* -------------------------------
   é–‹å§‹åˆ†é¡æŠ½ç±¤
------------------------------- */
async function startCategoryDraw(){
    document.getElementById("statusText").innerText =
        "åˆ†é¡è¼ªç›¤æŠ½ç±¤ä¸­â€¦";

    drawWheel(categories);
    let selectedCategory = await spinWheel(categories);

    document.getElementById("statusText").innerText =
        `æŠ½ä¸­åˆ†é¡ï¼šã€Œ${selectedCategory}ã€`;

    await new Promise(r=>setTimeout(r,1500));

    /* æŠ½ç¶“å¥ */
    let verseList = Object.keys(VERSE_REF_MAP);
    let usedVerses = JSON.parse(localStorage.getItem("usedVersesAll") || "[]");
    let available = verseList.filter(v => !usedVerses.includes(v));

    if(available.length === 0){
        alert("128 ç¯‡ç¶“æ–‡å·²æŠ½å®Œï¼");
        return;
    }

    let verse = available[Math.floor(Math.random()*available.length)];
    let ref = VERSE_REF_MAP[verse];

    document.getElementById("statusText").innerText =
        `æŠ½ä¸­ç¶“å¥ï¼šã€Œ${verse}ã€${ref ? `ï¼ˆ${ref}ï¼‰` : ""}`;

    /* ---- å¯«å…¥ç´€éŒ„ ---- */
    saveRecord(selectedCategory, verse, "åˆ†é¡æ¨¡å¼");

    await new Promise(r=>setTimeout(r,1400));

    /* è·³ viewer.html */
    window.location =
        `viewer.html?name=${encodeURIComponent(selectedCategory)}&verse=${verse}`;
}

/* -------------------------------
   å„²å­˜ç´€éŒ„
------------------------------- */
function saveRecord(name, verse, mode){

    let now = new Date();
    let ts =
        `${now.getFullYear()}/${String(now.getMonth()+1).padStart(2,"0")}/${String(now.getDate()).padStart(2,"0")} `+
        `${String(now.getHours()).padStart(2,"0")}:${String(now.getMinutes()).padStart(2,"0")}:${String(now.getSeconds()).padStart(2,"0")}`;

    let logs = JSON.parse(localStorage.getItem("drawLogs") || "[]");

    logs.push({
        time: ts,
        name: name,
        verseNo: verse,
        mode: mode
    });

    localStorage.setItem("drawLogs", JSON.stringify(logs));

    /* ç¶“æ–‡ä¸é‡è¤‡ */
    let used = JSON.parse(localStorage.getItem("usedVersesAll") || "[]");
    used.push(verse);
    localStorage.setItem("usedVersesAll", JSON.stringify(used));
}

/* -------------------------------
   å›é¦–é 
------------------------------- */
function goHome(){
    window.location = "index.html";
}

/* -------------------------------
   PDFï¼šè¼‰å…¥å¤–éƒ¨å­—å‹
------------------------------- */
async function loadFont(){
    const res = await fetch("fonts/NotoSansTC-Regular.ttf");
    const buf = await res.arrayBuffer();
    return btoa(
        new Uint8Array(buf).reduce((data,byte)=>data + String.fromCharCode(byte),"")
    );
}

/* -------------------------------
   PDF ç”¢ç”Ÿï¼ˆå–®è¡Œ + ç½®é ‚ç­†æ•¸ï¼‰
------------------------------- */
async function exportPDF(){

    let logs = JSON.parse(localStorage.getItem("drawLogs") || "[]");

    if(logs.length === 0){
        alert("ç›®å‰æ²’æœ‰æŠ½ç±¤ç´€éŒ„ï¼");
        return;
    }

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({
        unit:"pt",
        format:"a4"
    });

    const fontData = await loadFont();
    doc.addFileToVFS("NotoSansTC.ttf", fontData);
    doc.addFont("NotoSansTC.ttf","NotoSansTC","normal");
    doc.setFont("NotoSansTC");

    let y = 40;
    doc.setFontSize(16);

    doc.text(`BlessingCards128 æŠ½ç±¤ç´€éŒ„ï¼ˆå…± ${logs.length} ç­†ï¼‰`, 40, y);
    y += 30;

    doc.setFontSize(14);

    logs.forEach(log=>{
        let ref = VERSE_REF_MAP[log.verseNo] || "";
        let line =
            `[${log.time}] ${log.name}ï½œ${log.mode}ï½œæŠ½ä¸­ç¶“å¥ï¼š${log.verseNo}` +
            (ref ? `ï¼ˆ${ref}ï¼‰` : "");

        if(y > 780){
            doc.addPage();
            y = 40;
        }

        doc.text(line, 40, y);
        y += 22;
    });

    doc.save("BlessingCards128_æŠ½ç±¤ç´€éŒ„.pdf");
}
</script>

</body>
</html>
