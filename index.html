<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<title>BlessingCards128｜祝福經句紅包（v5.2）</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<style>
body {
    background: #fff8e7;
    font-family: "Noto Sans TC", sans-serif;
    text-align: center;
    padding: 22px;
    color: #5b3a00;
}

h1 {
    color: #b07500;
    font-size: 26px;
    margin-bottom: 10px;
}

.logo {
    width: 120px;
    margin-bottom: 14px;
}

/* 輸入框 */
#nameInput {
    width: 280px;
    padding: 10px;
    font-size: 18px;
    border-radius: 8px;
    border: 1px solid #bf8a3e;
    margin-bottom: 12px;
}

/* 按鈕 */
.btn {
    background: #f7c76c;
    border: none;
    padding: 12px 22px;
    border-radius: 25px;
    font-size: 18px;
    color: #5b3a00;
    cursor: pointer;
    margin: 6px;
}
.btn:hover {
    background: #f3b84f;
}
.btn:disabled {
    opacity: 0.45;
    cursor: not-allowed;
}

/* 第二輪閃爍 */
@keyframes blink {
    0% { opacity: 1; }
    50% { opacity: 0.25; }
    100% { opacity: 1; }
}
.blinking {
    animation: blink 1s infinite;
}

/* 輪盤容器 */
#wheelContainer {
    position: relative;
    width: 380px;
    height: 380px;
    margin: 22px auto;
}

/* canvas */
#wheelCanvas {
    width: 380px;
    height: 380px;
}

/* 指針 ▼（固定在上方朝下） */
#wheelPointer {
    position: absolute;
    top: -26px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 44px;
    color: red;
    z-index: 20;
}

/* 第二輪經句編號 Badge（指針下方） */
#verseBadge {
    position: absolute;
    top: 4px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 20px;
    font-weight: bold;
    color: #5b3a00;
    background: rgba(255,255,255,0.85);
    padding: 4px 10px;
    border-radius: 16px;
    border: 1px solid #e0b46a;
    display: none;
    z-index: 19;
}

/* 狀態訊息 */
#statusText {
    font-size: 20px;
    margin-top: 8px;
    color: #a56b00;
}
#statusText.error {
    color: #c0392b;
    font-weight: bold;
}
</style>
</head>

<body>

<h1>祝福經句紅包（BlessingCards128）</h1>
<img src="logo3524.png" class="logo" />

<!-- 姓名輸入 -->
<input id="nameInput" placeholder="請輸入姓名（用、或空白分隔）" /><br />

<button class="btn" onclick="lockList()">鎖定名單</button>
<button id="startBtn" class="btn" onclick="startFirstRound()">開始抽姓名 + 經句</button>
<button class="btn" onclick="resetAll()">全部歸零</button>
<button class="btn" onclick="exportPDF()">抽籤紀錄 PDF</button>

<button id="secondBtn" class="btn" style="display:none;" onclick="startSecondRound()">抽紅包（第二輪）</button>
<button id="viewerBtn" class="btn" style="display:none;" onclick="gotoViewer()">看紅包內容</button>

<div id="wheelContainer">
    <div id="wheelPointer">▼</div>
    <div id="verseBadge"></div>
    <canvas id="wheelCanvas" width="380" height="380"></canvas>
</div>

<div id="statusText">請輸入姓名並鎖定名單</div>

<script src="verseRefMap.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script>
/* ================================
   全域變數 & LocalStorage 工具
================================ */
const LS_PREFIX = "BC128_";

let nameList = [];
let locked = false;

let selectedName = null;     // 第 1 輪抽中的姓名
let selectedVerse = null;    // 第 2 輪抽中的經句編號
let selectedTime = null;     // 本次抽中的時間字串（給 viewer + PNG 用）

let usedNames = [];          // 已完成兩輪的人
let usedVerses = [];         // 已抽過的經句編號
let roundFinished = false;   // 本輪是否全部抽完
let awaitingSecond = false;  // 是否在「第 1 輪已抽完、等待第 2 輪」

const canvas = document.getElementById("wheelCanvas");
const ctx = canvas.getContext("2d");
const CENTER = 190;
const RADIUS = 180;

const startBtn = document.getElementById("startBtn");
const secondBtn = document.getElementById("secondBtn");
const viewerBtn = document.getElementById("viewerBtn");
const statusText = document.getElementById("statusText");
const verseBadge = document.getElementById("verseBadge");

function lsGet(key, def) {
    const v = localStorage.getItem(LS_PREFIX + key);
    if (v === null || v === undefined) return def;
    try { return JSON.parse(v); } catch { return def; }
}
function lsSet(key, value) {
    localStorage.setItem(LS_PREFIX + key, JSON.stringify(value));
}

/* ================================
   音效
================================ */
function playDrum() {
    const a = new Audio("audio/drum.mp3");
    a.play().catch(() => {});
}

/* ================================
   初始化：讀取 LocalStorage
================================ */
(function init(){
    const savedList = lsGet("nameList", null);
    if (savedList && Array.isArray(savedList) && savedList.length >= 2) {
        nameList = savedList;
        locked = true;
        document.getElementById("nameInput").value = nameList.join("、");
        statusText.textContent = `名單已載入，共 ${nameList.length} 位`;
        drawWheel(nameList);   // 靜態輪盤
    }

    usedNames = lsGet("usedNames", []);
    usedVerses = lsGet("usedVerses", []);
    roundFinished = !!lsGet("roundFinished", false);
    awaitingSecond = !!lsGet("awaitingSecond", false);

    selectedName  = lsGet("currentName", null);
    selectedVerse = lsGet("currentVerse", null);
    selectedTime  = lsGet("currentTime", null);

    if (roundFinished && nameList.length > 0) {
        statusText.textContent = "⚠ 本輪已完成全部抽籤，請按「全部歸零」。";
        startBtn.disabled = true;
    }

    if (awaitingSecond && selectedName && !selectedVerse) {
        // 上次停在「第 1 輪已抽完」，但還沒抽第二輪
        statusText.textContent = `第 1 輪完成：抽中「${selectedName}」，請先按「抽紅包（第二輪）」`;
        secondBtn.style.display = "inline-block";
        secondBtn.classList.add("blinking");
    }
})();

/* ================================
   畫輪盤（靜態、不旋轉）
   items: 顯示用名字陣列
================================ */
function drawWheel(items, opt = {}) {
    const { hideText = false, winnerIndex = null, highlightVerseText = "" } = opt;

    ctx.clearRect(0, 0, 380, 380);
    if (!items || !items.length) return;

    const count = items.length;
    const arc = Math.PI * 2 / count;

    // 我們刻意讓 index 0 的扇區中心在「指針下方」
    // 起始角度從 -90° 開始
    for (let i = 0; i < count; i++) {
        const start = arc * i - Math.PI / 2;
        const end   = start + arc;

        // 扇形背景
        ctx.beginPath();
        ctx.moveTo(CENTER, CENTER);
        ctx.arc(CENTER, CENTER, RADIUS, start, end);
        ctx.closePath();
        ctx.fillStyle = (i % 2 === 0) ? "#fde7b5" : "#fcdca0";
        ctx.fill();

        // 白色分隔線
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.stroke();

        if (!hideText) {
            // 寫上姓名
            ctx.save();
            ctx.translate(CENTER, CENTER);
            const mid = start + arc/2;
            ctx.rotate(mid);
            ctx.textAlign = "right";
            ctx.font = "22px Noto Sans TC";
            ctx.fillStyle = "#5b3a00";
            ctx.fillText(items[i], RADIUS - 22, 10);
            ctx.restore();
        }
    }

    // 第二輪：若有需要在中獎扇區中畫上經句編號
    if (winnerIndex != null && highlightVerseText) {
        const start = arc * winnerIndex - Math.PI/2;
        const mid   = start + arc/2;
        ctx.save();
        ctx.translate(CENTER, CENTER);
        ctx.rotate(mid);
        ctx.textAlign = "right";
        ctx.font = "24px Noto Sans TC";
        ctx.fillStyle = "#b03a00";
        ctx.fillText(highlightVerseText, RADIUS - 40, 10);
        ctx.restore();
    }
}

/* ================================
   輪盤動畫（僅視覺用，不用角度算中獎）
   → 播放 4~6 圈，結束後 resolve()
================================ */
function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

function spinVisual(items, clockwise, options = {}){
    const { hideText = false } = options;
    return new Promise(resolve => {
        playDrum();

        const count = items.length;
        const arc   = Math.PI * 2 / count;

        const spins = 4 + Math.random() * 2; // 4~6 圈
        const direction = clockwise ? 1 : -1;
        const totalAngle = direction * spins * 2 * Math.PI;

        const startTime = performance.now();
        const duration  = 5000;

        function frame(now){
            let t = (now - startTime) / duration;
            if (t > 1) t = 1;
            const eased = easeOutCubic(t);
            const angle = totalAngle * eased;

            ctx.save();
            ctx.clearRect(0,0,380,380);
            ctx.translate(CENTER, CENTER);
            ctx.rotate(angle);
            ctx.translate(-CENTER, -CENTER);
            drawWheel(items, { hideText });
            ctx.restore();

            if (t < 1){
                requestAnimationFrame(frame);
            } else {
                resolve();
            }
        }
        requestAnimationFrame(frame);
    });
}

/* ================================
   鎖定名單
================================ */
function lockList(){
    const raw = document.getElementById("nameInput").value.trim();
    if (!raw){
        alert("請先輸入姓名！");
        return;
    }

    const arr = raw.split(/[,、\s]+/)
        .map(s => s.trim())
        .filter(s => s.length > 0);

    if (arr.length < 2){
        alert("至少要兩位姓名才能轉輪盤！");
        return;
    }

    nameList = arr;
    locked = true;
    usedNames = [];
    usedVerses = [];
    roundFinished = false;
    awaitingSecond = false;
    selectedName = null;
    selectedVerse = null;
    selectedTime = null;

    lsSet("nameList", nameList);
    lsSet("usedNames", []);
    lsSet("usedVerses", []);
    lsSet("roundFinished", false);
    lsSet("awaitingSecond", false);
    lsSet("currentName", null);
    lsSet("currentVerse", null);
    lsSet("currentTime", null);

    statusText.textContent = `名單已鎖定，共 ${nameList.length} 位`;
    startBtn.disabled = false;
    secondBtn.style.display = "none";
    viewerBtn.style.display = "none";
    verseBadge.style.display = "none";

    drawWheel(nameList);
}

/* ================================
   第一輪：抽姓名（逆時針）
   規則：
   - 若上一位已抽完第 1 輪但尚未抽第 2 輪，禁止重新開始
================================ */
async function startFirstRound(){
    if (roundFinished){
        alert("本輪已完成全部抽籤，請按「全部歸零」。");
        return;
    }
    if (!locked || nameList.length < 2){
        alert("請先輸入姓名並鎖定名單！");
        return;
    }
    if (awaitingSecond && selectedName && !selectedVerse){
        alert("已抽完第 1 輪，請先按「抽紅包（第二輪）」再開始下一位！");
        return;
    }

    const remaining = nameList.filter(n => !usedNames.includes(n));
    if (!remaining.length){
        alert("全部姓名都已完成紅包抽籤！");
        roundFinished = true;
        lsSet("roundFinished", true);
        startBtn.disabled = true;
        return;
    }

    // 隨機從尚未抽過的人中選出 winner
    const winner = remaining[Math.floor(Math.random()*remaining.length)];
    const winnerIndex = nameList.indexOf(winner);

    selectedName  = winner;
    selectedVerse = null;
    selectedTime  = null;
    awaitingSecond = true;
    lsSet("currentName", winner);
    lsSet("currentVerse", null);
    lsSet("currentTime", null);
    lsSet("awaitingSecond", true);

    statusText.textContent = "第 1 輪：姓名輪盤抽籤中…";
    verseBadge.style.display = "none";
    viewerBtn.style.display = "none";

    // 視覺動畫（不影響中獎結果）
    await spinVisual(nameList, false, { hideText:false });

    // 動畫結束後，重畫讓「winner 在 index 0 → 正好在指針下方」
    const rotated = [];
    for (let i=0;i<nameList.length;i++){
        rotated.push(nameList[(winnerIndex + i) % nameList.length]);
    }
    drawWheel(rotated);

    statusText.textContent = `第 1 輪完成：抽中「${winner}」`;

    setTimeout(() => {
        secondBtn.style.display = "inline-block";
        secondBtn.classList.add("blinking");
    }, 800);
}

/* ================================
   第二輪：抽經句（順時針）
   - 外觀：同姓名輪盤，但不顯示文字（空白切片）
   - 內部：從 001–128 未抽過的經句中抽一個
   - 結束：指針仍停在第一輪同一格，badge 顯示編號
================================ */
async function startSecondRound(){
    secondBtn.classList.remove("blinking");
    secondBtn.style.display = "none";

    if (!selectedName){
        alert("請先完成第一輪抽姓名！");
        return;
    }

    const verseNums = Object.keys(window.VERSE_REF_MAP || {});
    if (!verseNums.length){
        alert("找不到經句對照表（VERSE_REF_MAP）！");
        return;
    }

    const available = verseNums.filter(v => !usedVerses.includes(v));
    if (!available.length){
        alert("128 篇經句都已經抽完了！");
        return;
    }

    statusText.textContent = "第 2 輪：祝福經句輪盤抽籤中…";
    verseBadge.style.display = "none";

    const winnerIndex = nameList.indexOf(selectedName);
    if (winnerIndex < 0){
        alert("內部錯誤：找不到中獎姓名的位置。");
        return;
    }

    // 視覺動畫：仍以 nameList 為切片，但不顯示文字
    await spinVisual(nameList, true, { hideText:true });

    // 動畫結束後，重畫：winner 放 index 0 → 指針下方
    const rotated = [];
    for (let i=0;i<nameList.length;i++){
        rotated.push(nameList[(winnerIndex + i) % nameList.length]);
    }
    // 第二輪不顯示文字，但在 0 號扇區中央用 highlightVerseText 寫上編號
    selectedVerse = available[Math.floor(Math.random()*available.length)];
    usedVerses.push(selectedVerse);
    lsSet("usedVerses", usedVerses);

    const ref = (window.VERSE_REF_MAP || {})[selectedVerse] || "";
    const verseText = `編號「${selectedVerse}」`;

    drawWheel(rotated, {
        hideText:true,
        winnerIndex:0,
        highlightVerseText: verseText
    });

    // 在指針下方顯示 badge
    verseBadge.textContent = verseText;
    verseBadge.style.display = "block";

    // 建立時間戳記
    const now = new Date();
    const ts =
        `${now.getFullYear()}/`+
        `${String(now.getMonth()+1).padStart(2,"0")}/`+
        `${String(now.getDate()).padStart(2,"0")} `+
        `${String(now.getHours()).padStart(2,"0")}:`+
        `${String(now.getMinutes()).padStart(2,"0")}:`+
        `${String(now.getSeconds()).padStart(2,"0")}`;

    selectedTime = ts;
    lsSet("currentVerse", selectedVerse);
    lsSet("currentTime", selectedTime);

    statusText.textContent = `第 2 輪完成：抽中經句「${selectedVerse}」`;

    // 寫入紀錄
    saveRecord(selectedName, selectedVerse, selectedTime);

    awaitingSecond = false;
    lsSet("awaitingSecond", false);

    setTimeout(() => {
        viewerBtn.style.display = "inline-block";
    }, 800);
}

/* ================================
   儲存抽籤紀錄
================================ */
function saveRecord(name, verse, timeStr){
    const ref = (window.VERSE_REF_MAP || {})[verse] || "";
    let logs = lsGet("drawLogs", []);
    logs.push({
        time: timeStr,
        mode: "姓名模式",
        name,
        verse,
        ref
    });
    lsSet("drawLogs", logs);

    if (!usedNames.includes(name)){
        usedNames.push(name);
        lsSet("usedNames", usedNames);
    }

    // 只有「完成第二輪」才算此人抽完
    if (usedNames.length >= nameList.length){
        roundFinished = true;
        lsSet("roundFinished", true);
        startBtn.disabled = true;
        // 不立刻 alert，讓流程自然留在 viewer 再回首頁時再感受到已完成
    }
}

/* ================================
   前往 viewer.html（帶 name, verse, time）
================================ */
function gotoViewer(){
    if (!selectedName || !selectedVerse){
        alert("請先完成兩輪抽籤！");
        return;
    }
    const url =
        `viewer.html?name=${encodeURIComponent(selectedName)}`+
        `&verse=${encodeURIComponent(selectedVerse)}`+
        `&time=${encodeURIComponent(selectedTime || "")}`;
    window.location.href = url;
}

/* ================================
   全部歸零
================================ */
function resetAll(){
    if (!confirm("確定要清除目前這一輪的所有資料嗎？")) return;
    Object.keys(localStorage)
        .filter(k => k.startsWith(LS_PREFIX))
        .forEach(k => localStorage.removeItem(k));
    alert("所有資料已清空！");
    location.reload();
}

/* ================================
   PDF 匯出（外部字型：思源黑體）
================================ */
async function exportPDF(){
    let logs = lsGet("drawLogs", []);
    if (!logs.length){
        alert("目前尚無抽籤紀錄！");
        return;
    }

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit:"pt", format:"a4" });

    // 載入外部字型
    let fontData;
    try {
        const res = await fetch("fonts/SourceHanSansTC-Regular.ttf");
        const buf = await res.arrayBuffer();
        const bytes = new Uint8Array(buf);
        let binary = "";
        for (let i=0;i<bytes.length;i++){
            binary += String.fromCharCode(bytes[i]);
        }
        fontData = btoa(binary);
    } catch(e){
        console.error(e);
        alert("無法載入字型 fonts/SourceHanSansTC-Regular.ttf，請確認檔案存在。");
        return;
    }

    doc.addFileToVFS("SourceHanSansTC-Regular.ttf", fontData);
    doc.addFont("SourceHanSansTC-Regular.ttf", "SourceHanTC", "normal");
    doc.setFont("SourceHanTC", "normal");

    doc.setFontSize(18);
    doc.text("BlessingCards128 抽籤紀錄", 40, 40);

    let y = 70;
    doc.setFontSize(13);

    logs.forEach(log => {
        const line =
            `[${log.time}] ${log.name}｜${log.mode} 抽中經句：${log.verse}`+
            (log.ref ? `（${log.ref}）` : "");
        doc.text(line, 40, y);
        y += 22;
        if (y > 780){
            doc.addPage();
            y = 60;
        }
    });

    doc.save("BlessingCards128_抽籤紀錄.pdf");
}
</script>
</body>
</html>
