<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>祝福經句紅包（BlessingCards128 v4.7）</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
body {
    background: #fff9e9;
    font-family: "Noto Sans TC", sans-serif;
    text-align: center;
    padding: 20px;
    color: #5a3d00;
}

h1 {
    font-size: 26px;
    color: #b06b00;
    margin-bottom: 12px;
}

/* 姓名輸入框 */
#nameInput {
    width: 280px;
    padding: 10px;
    border-radius: 8px;
    border: 1px solid #b4843a;
    font-size: 18px;
    margin-bottom: 12px;
}

/* 通用按鈕 */
.btn {
    background: #f7c86c;
    padding: 12px 22px;
    border-radius: 25px;
    font-size: 18px;
    color: #5a3d00;
    cursor: pointer;
    border: none;
    margin: 6px;
}
.btn:hover { background: #f5b953; }
.btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* 抽紅包按鈕閃爍效果 */
@keyframes blink {
    0% { opacity: 1; }
    50% { opacity: 0.3; }
    100% { opacity: 1; }
}
.blinking {
    animation: blink 0.9s infinite;
}

/* 轉盤容器 */
#wheelContainer {
    position: relative;
    width: 380px;
    height: 380px;
    margin: 25px auto;
}

#wheelCanvas {
    width: 380px;
    height: 380px;
}

/* 指針 ▼ （貼齊上方外緣） */
#wheelPointer {
    position: absolute;
    top: -22px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 42px;
    color: red;
    z-index: 10;
}

/* 狀態文字 */
#statusText {
    font-size: 20px;
    margin-top: 15px;
    color: #b06b00;
}
#statusText.error {
    color: #c0392b;
    font-weight: bold;
}

/* PDF 錯誤訊息（可共用 statusText，不另外拉元素） */
</style>
</head>

<body>

<h1>祝福經句紅包（BlessingCards128）</h1>
<img src="logo3524.png" width="120" style="margin-bottom:12px;">

<!-- 姓名輸入（以 、 或 , 或空白 分隔多人） -->
<input id="nameInput" placeholder="請輸入姓名，以「、」隔開多人"><br>

<button id="lockBtn" class="btn" onclick="lockList()">鎖定名單</button>
<button id="startBtn" class="btn" onclick="startFirstRound()">開始抽姓名 + 經句</button>
<button class="btn" onclick="resetAll()">全部歸零</button>
<button class="btn" onclick="exportPDF()">抽籤紀錄 PDF</button>

<!-- 第二階段按鈕 -->
<button id="stage2Btn" class="btn" onclick="startSecondRound()" style="display:none;">抽紅包（第二輪）</button>
<button id="stage3Btn" class="btn" onclick="gotoViewer()" style="display:none;">看紅包內容</button>

<div id="wheelContainer">
    <div id="wheelPointer">▼</div>
    <canvas id="wheelCanvas" width="380" height="380"></canvas>
</div>

<div id="statusText">請輸入姓名並鎖定名單</div>

<script src="verseRefMap.js"></script>
<!-- jsPDF 2.5.1 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script>
/* ===============================
   全域狀態
=============================== */
let nameList = [];
let locked = false;
let selectedName = null;
let selectedVerse = null;

let usedNames = [];     // 本輪已抽過紅包的姓名
let roundFinished = false;      // 是否已完成本輪
const ROUND_FINISHED_KEY = "roundFinished";
const ROUND_FINISHED_JUSTWARN_KEY = "roundFinishedJustWarn";

const CENTER = 190;
const RADIUS = 180;
const canvas = document.getElementById("wheelCanvas");
const ctx = canvas.getContext("2d");

const statusTextEl = document.getElementById("statusText");
const startBtn = document.getElementById("startBtn");
const stage2Btn = document.getElementById("stage2Btn");
const stage3Btn = document.getElementById("stage3Btn");

/* ===============================
   初始化：從 localStorage 載入
=============================== */
(function initFromStorage(){
    // 名單
    const saved = localStorage.getItem("nameList");
    if(saved){
        try{
            const arr = JSON.parse(saved);
            if(Array.isArray(arr) && arr.length >= 2){
                nameList = arr;
                locked = true;
                document.getElementById("nameInput").value = nameList.join("、");
                statusTextEl.innerText =
                    "名單已載入，共 " + nameList.length + " 位。可直接按「開始抽姓名 + 經句」。";
            }
        }catch(e){
            console.warn("nameList parse error", e);
        }
    }

    // 已抽過姓名
    const used = localStorage.getItem("usedNames");
    if(used){
        try{
            const arr2 = JSON.parse(used);
            if(Array.isArray(arr2)){
                usedNames = arr2;
            }
        }catch(e){
            console.warn("usedNames parse error", e);
        }
    }

    // 本輪是否已完成
    roundFinished = (localStorage.getItem(ROUND_FINISHED_KEY) === "1");

    if(nameList.length >= 2){
        drawWheel(nameList);
    }

    if(roundFinished && nameList.length > 0){
        // 回首頁時顯示提示
        const justWarn = (localStorage.getItem(ROUND_FINISHED_JUSTWARN_KEY) === "1");
        setFinishedState();
        if(justWarn){
            alert(
                "此輪轉盤已完成 " + nameList.length + " 位的紅包抽籤，\n" +
                "請按「全部歸零」並重新輸入姓名，再開始新一輪的紅包抽籤。"
            );
            localStorage.setItem(ROUND_FINISHED_JUSTWARN_KEY, "0");
        }
    }
})();

/* 將狀態改為「本輪已完成」：停用按鈕 + 顯示紅字 */
function setFinishedState(){
    roundFinished = true;
    startBtn.disabled = true;
    stage2Btn.style.display = "none";
    stage3Btn.style.display = "none";
    statusTextEl.classList.add("error");
    statusTextEl.innerText =
        "⚠ 已完成本輪全部姓名的抽籤，請按「全部歸零」開始新的一輪。";
}

/* ===============================
   鎖定名單
=============================== */
function lockList(){
    const raw = document.getElementById("nameInput").value.trim();
    if(raw === ""){
        alert("請輸入至少 2 位姓名！");
        return;
    }
    const arr = raw.split(/[,、\s]+/).filter(x => x.trim() !== "");
    if(arr.length < 2){
        alert("至少需要 2 位姓名！");
        return;
    }
    nameList = arr;
    locked = true;
    usedNames = [];
    roundFinished = false;
    localStorage.setItem("nameList", JSON.stringify(nameList));
    localStorage.removeItem("usedNames");
    localStorage.removeItem(ROUND_FINISHED_KEY);
    localStorage.removeItem(ROUND_FINISHED_JUSTWARN_KEY);

    startBtn.disabled = false;
    statusTextEl.classList.remove("error");
    statusTextEl.innerText = "名單已鎖定，共 " + nameList.length + " 位。";

    drawWheel(nameList);
}

/* ===============================
   畫輪盤（姓名切片）
=============================== */
function drawWheel(items){
    ctx.clearRect(0,0,380,380);
    if(!items || items.length === 0) return;

    const count = items.length;
    const arc = Math.PI * 2 / count;

    for(let i=0;i<count;i++){
        const start = arc * i;
        const end   = arc * (i+1);

        ctx.beginPath();
        ctx.fillStyle = (i % 2 === 0) ? "#fde7b5" : "#fcdca0";
        ctx.moveTo(CENTER, CENTER);
        ctx.arc(CENTER, CENTER, RADIUS, start, end);
        ctx.closePath();
        ctx.fill();

        /* 分隔線 */
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.stroke();

        /* 姓名文字 */
        ctx.save();
        ctx.translate(CENTER, CENTER);
        const mid = start + (end - start)/2;
        ctx.rotate(mid);
        ctx.textAlign = "right";
        ctx.font = "22px Noto Sans TC";
        ctx.fillStyle = "#5a3d00";
        ctx.fillText(items[i], RADIUS - 20, 10);
        ctx.restore();
    }
}

/* easeOut 動畫 */
function easeOut(t){ return 1 - Math.pow(1 - t, 3); }

/* Drum 音效：每輪轉動播放一次 */
function playDrum(){
    const s = new Audio("audio/drum.mp3");
    s.play().catch(()=>{});
}

/* ===============================
   輪盤動畫（預先決定 index，保證指針命中）
=============================== */
function spinWheel(items, clockwise, forcedIndex){
    return new Promise(resolve => {

        if(!items || items.length === 0){
            resolve(null);
            return;
        }

        playDrum();

        const count = items.length;
        const arc = Math.PI * 2 / count;
        const pointerAngle = Math.PI / 2; // 指針向下 = +90°

        const spins = 5 + Math.random() * 1.5; // 5 ~ 6.5 圈
        const direction = clockwise ? 1 : -1;

        // 預先決定中獎 index，保證落在那一格
        const selectedIndex = (typeof forcedIndex === "number" && forcedIndex >=0 && forcedIndex < count)
            ? forcedIndex
            : Math.floor(Math.random() * count);

        // slice 中心角度（以右方 0rad 為起點）
        const sliceCenter = arc * selectedIndex + arc/2;

        // 最終角度 = 讓 sliceCenter 對準 pointerAngle，再加上多圈
        const finalAngle = pointerAngle - sliceCenter + direction * spins * 2 * Math.PI;

        const start = performance.now();
        const duration = 5000; // 5 秒

        function animate(now){
            let t = (now - start) / duration;
            if(t > 1) t = 1;
            const eased = easeOut(t);
            const angle = finalAngle * eased;

            ctx.save();
            ctx.clearRect(0,0,380,380);
            ctx.translate(CENTER, CENTER);
            ctx.rotate(angle);
            ctx.translate(-CENTER, -CENTER);
            drawWheel(items);
            ctx.restore();

            if(t < 1){
                requestAnimationFrame(animate);
            }else{
                resolve(items[selectedIndex]);
            }
        }

        requestAnimationFrame(animate);
    });
}

/* ===============================
   第一輪：姓名輪盤
=============================== */
async function startFirstRound(){

    statusTextEl.classList.remove("error");

    if(roundFinished){
        alert(
            "此輪轉盤已完成 " + nameList.length + " 位的紅包抽籤，\n" +
            "請按「全部歸零」並重新輸入姓名，再開始新一輪的紅包抽籤。"
        );
        setFinishedState();
        return;
    }

    if(!locked){
        alert("請先鎖定名單！");
        return;
    }
    if(!nameList || nameList.length < 2){
        alert("名單不足，請重新鎖定。");
        return;
    }

    // 剩下尚未抽過的姓名
    const remaining = nameList.filter(n => !usedNames.includes(n));
    if(remaining.length === 0){
        // 理論上不會到這邊，保險一下
        localStorage.setItem(ROUND_FINISHED_KEY, "1");
        localStorage.setItem(ROUND_FINISHED_JUSTWARN_KEY, "1");
        setFinishedState();
        return;
    }

    // 從 remaining 中隨機抽一位（真正中獎人）
    const winnerName = remaining[Math.floor(Math.random() * remaining.length)];
    const forcedIndex = nameList.indexOf(winnerName);

    selectedName = null;
    selectedVerse = null;
    stage2Btn.style.display = "none";
    stage2Btn.classList.remove("blinking");
    stage3Btn.style.display = "none";

    statusTextEl.innerText = "第 1 輪：姓名輪盤抽籤中…";

    drawWheel(nameList);
    // 第一輪：逆時針
    const visName = await spinWheel(nameList, false, forcedIndex);

    // 雙重保險：視覺與邏輯應該一樣
    selectedName = winnerName;

    statusTextEl.innerText =
        "第 1 輪完成：抽中「" + selectedName + "」";

    setTimeout(()=>{
        stage2Btn.style.display = "inline-block";
        stage2Btn.classList.add("blinking");
    }, 1200);
}

/* ===============================
   第二輪：經句輪盤（外觀同姓名輪盤）
=============================== */
async function startSecondRound(){

    stage2Btn.classList.remove("blinking");
    stage2Btn.style.display = "none";
    statusTextEl.classList.remove("error");

    if(!selectedName){
        alert("請先完成第一輪姓名抽籤！");
        return;
    }

    // 取得可用的經句編號（避免經句重複）
    const verseList = Object.keys(VERSE_REF_MAP);
    const usedVersesAll = JSON.parse(localStorage.getItem("usedVersesAll") || "[]");
    const available = verseList.filter(v => !usedVersesAll.includes(v));

    if(available.length === 0){
        alert("128 篇經文已全部抽完！");
        return;
    }

    statusTextEl.innerText = "第 2 輪：祝福經句輪盤抽籤中…";

    drawWheel(nameList);
    // 第二輪：順時針，外觀用姓名輪盤即可，真正經句由 available 隨機
    await spinWheel(nameList, true, null);

    selectedVerse = available[Math.floor(Math.random() * available.length)];

    statusTextEl.innerText =
        "第 2 輪完成：抽中經句「" + selectedVerse + "」";

    // 寫入抽籤紀錄（姓名模式 + 避免經句重複 + 紀錄已抽姓名）
    saveRecord(selectedName, selectedVerse);

    setTimeout(()=>{
        stage3Btn.style.display = "inline-block";
    }, 1200);
}

/* ===============================
   前往 viewer.html 看紅包內容
=============================== */
function gotoViewer(){
    if(!selectedName || !selectedVerse){
        alert("請先完成姓名與經句抽籤！");
        return;
    }
    window.location =
        `viewer.html?name=${encodeURIComponent(selectedName)}&verse=${selectedVerse}`;
}

/* ===============================
   儲存抽籤紀錄（姓名模式）
=============================== */
function saveRecord(name, verse){

    const now = new Date();
    const ts =
        `${now.getFullYear()}/${String(now.getMonth()+1).padStart(2,"0")}/${String(now.getDate()).padStart(2,"0")} `+
        `${String(now.getHours()).padStart(2,"0")}:${String(now.getMinutes()).padStart(2,"0")}:${String(now.getSeconds()).padStart(2,"0")}`;

    const logs = JSON.parse(localStorage.getItem("drawLogs") || "[]");
    logs.push({
        time: ts,
        name: name,
        verseNo: verse,
        mode: "姓名模式"
    });
    localStorage.setItem("drawLogs", JSON.stringify(logs));

    // 避免經句重複
    const usedVersesAll = JSON.parse(localStorage.getItem("usedVersesAll") || "[]");
    usedVersesAll.push(verse);
    localStorage.setItem("usedVersesAll", JSON.stringify(usedVersesAll));

    // 紀錄已抽過的姓名（每人本輪只能抽一次）
    if(!usedNames.includes(name)){
        usedNames.push(name);
        localStorage.setItem("usedNames", JSON.stringify(usedNames));
    }

    // 若所有姓名都抽完，標記本輪結束
    if(nameList.length > 0 && usedNames.length >= nameList.length){
        localStorage.setItem(ROUND_FINISHED_KEY, "1");
        localStorage.setItem(ROUND_FINISHED_JUSTWARN_KEY, "1");
        roundFinished = true;
    }
}

/* ===============================
   全部歸零
=============================== */
function resetAll(){
    localStorage.removeItem("usedVersesAll");
    localStorage.removeItem("drawLogs");
    localStorage.removeItem("nameList");
    localStorage.removeItem("usedNames");
    localStorage.removeItem(ROUND_FINISHED_KEY);
    localStorage.removeItem(ROUND_FINISHED_JUSTWARN_KEY);
    alert("所有資料已清空！將重新載入。");
    location.reload();
}

/* ===============================
   PDF 匯出（外部字型 SourceHanSansTC-Regular.ttf）
=============================== */

async function loadFontBinary(){
    // 這裡改用輕量穩定方案：外部 TTF 檔放在 fonts/ 下
    // 請確保路徑存在：fonts/SourceHanSansTC-Regular.ttf
    try{
        const res = await fetch("fonts/SourceHanSansTC-Regular.ttf");
        if(!res.ok){
            throw new Error("HTTP " + res.status);
        }
        const buf = await res.arrayBuffer();
        const bytes = new Uint8Array(buf);
        let binary = "";
        for(let i=0;i<bytes.length;i++){
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    }catch(e){
        console.error("載入 PDF 字型失敗：", e);
        throw e;
    }
}

async function exportPDF(){

    statusTextEl.classList.remove("error");

    const logs = JSON.parse(localStorage.getItem("drawLogs") || "[]");
    if(logs.length === 0){
        alert("目前沒有抽籤紀錄，無法產生 PDF！");
        statusTextEl.classList.add("error");
        statusTextEl.innerText = "目前沒有抽籤紀錄，請先完成至少一次抽籤後再產生 PDF。";
        return;
    }

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit:"pt", format:"a4" });

    let fontData;
    try{
        fontData = await loadFontBinary();
    }catch(e){
        alert("PDF 字型載入失敗，請確認 fonts/SourceHanSansTC-Regular.ttf 是否存在。");
        statusTextEl.classList.add("error");
        statusTextEl.innerText = "PDF 字型載入失敗，請確認 fonts/SourceHanSansTC-Regular.ttf 檔案存在於專案內。";
        return;
    }

    try{
        doc.addFileToVFS("SourceHanSansTC-Regular.ttf", fontData);
        doc.addFont("SourceHanSansTC-Regular.ttf","SourceHanSansTC","normal");
        doc.setFont("SourceHanSansTC","normal");
    }catch(e){
        console.error("註冊 PDF 字型失敗：", e);
        alert("PDF 字型註冊失敗，請稍後再試。");
        statusTextEl.classList.add("error");
        statusTextEl.innerText = "PDF 字型註冊失敗，請檢查 jsPDF 版本或字型檔。";
        return;
    }

    let y = 40;
    doc.setFontSize(16);
    doc.text(`BlessingCards128 抽籤紀錄（共 ${logs.length} 筆）`, 40, y);
    y += 30;

    doc.setFontSize(14);

    logs.forEach(log =>{
        const ref = VERSE_REF_MAP[log.verseNo] || "";
        const line =
            `[${log.time}] ${log.name}｜${log.mode}｜抽中經句：${log.verseNo}` +
            (ref ? `（${ref}）` : "");

        if(y > 780){
            doc.addPage();
            y = 40;
        }
        doc.text(line, 40, y);
        y += 22;
    });

    doc.save("BlessingCards128_抽籤紀錄.pdf");
}
</script>

</body>
</html>
