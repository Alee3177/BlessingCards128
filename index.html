<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BlessingCards128｜祝福經句紅包（應許等您拿）v7.5 Stable Final</title>

  <!-- 加速 logo 載入 -->
  <link rel="preload" as="image" href="logo3524.png">

  <style>
    :root{
      --bg:#fff6e4;
      --text:#5b3a00;
      --accent:#b07500;
      --btn:#f7c76c;
      --btn2:#f3b84f;
      --danger:#c0392b;
    }
    body{
      margin:0;
      background:var(--bg);
      font-family: "Noto Sans TC", system-ui, -apple-system, "Segoe UI", Arial, sans-serif;
      color:var(--text);
      text-align:center;
      padding:22px 14px 40px;
    }
    h1{
      margin:0 0 10px;
      color:var(--accent);
      font-size:28px;
      letter-spacing:.5px;
    }
    .logo{
      width:128px;
      margin:10px auto 14px;
      display:block;
    }
    #nameInput{
      width:min(560px, 86vw);
      padding:10px 12px;
      font-size:18px;
      border-radius:10px;
      border:1px solid #bf8a3e;
      outline:none;
      background:#fff;
      box-sizing:border-box;
    }
    .row{
      margin-top:12px;
      display:flex;
      flex-wrap:wrap;
      justify-content:center;
      gap:10px;
    }
    .btn{
      background:var(--btn);
      border:none;
      padding:12px 18px;
      border-radius:26px;
      font-size:18px;
      color:var(--text);
      cursor:pointer;
      min-width:132px;
    }
    .btn:hover{ background:var(--btn2); }
    .btn:disabled{ opacity:.45; cursor:not-allowed; }

    @keyframes blink { 0%{opacity:1} 50%{opacity:.28} 100%{opacity:1} }
    .blinking{ animation:blink 1s infinite; }

    #wheelContainer{
      position:relative;
      width:420px;
      height:420px;
      margin:18px auto 6px;
    }
    @media (max-width:520px){
      #wheelContainer{ width:340px; height:340px; }
    }
    #wheelCanvas{
      width:100%;
      height:100%;
      display:block;
      margin:0 auto;
    }
    #wheelPointer{
      position:absolute;
      top:-18px;
      left:50%;
      transform:translateX(-50%);
      font-size:46px;
      color:#d40000;
      line-height:1;
      z-index:10;
      text-shadow: 0 1px 0 rgba(0,0,0,.08);
      user-select:none;
      pointer-events:none;
    }

    #statusText{
      margin:10px auto 0;
      font-size:18px;
      color:#a56b00;
      min-height:28px;
      white-space:pre-line;
    }
    #statusText.error{
      color:var(--danger);
      font-weight:700;
    }

    /* 轉盤中間的「書卷 / 章節」顯示 */
    #centerOverlay{
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      width:62%;
      pointer-events:none;
      user-select:none;
      text-align:center;
      display:none;
    }
    #centerOverlay .book{
      font-size:20px;
      font-weight:700;
      color:#7a4b00;
      line-height:1.15;
      margin-bottom:4px;
    }
    #centerOverlay .ref{
      font-size:18px;
      color:#7a4b00;
      line-height:1.15;
    }
  </style>
</head>

<body>
  <h1>祝福經句紅包（應許等您拿）</h1>
  <img class="logo" src="logo3524.png" alt="logo" loading="eager" decoding="async">

  <div>
    <input id="nameInput" placeholder="輸入所有姓名，用「,」或「、」或空白分隔" autocomplete="off" />
  </div>

  <div class="row">
    <button id="lockBtn" class="btn" type="button">鎖定名單</button>
    <button id="startBtn" class="btn" type="button">開始抽姓名 + 經句</button>
    <button id="resetBtn" class="btn" type="button">全部歸零</button>
    <button id="pdfBtn" class="btn" type="button">抽籤紀錄 PDF</button>
  </div>

  <div class="row" style="margin-top:10px">
    <button id="secondBtn" class="btn" type="button" style="display:none">抽紅包（第二輪）</button>
    <button id="viewerBtn" class="btn" type="button" style="display:none">看紅包內容</button>
  </div>

  <div id="wheelContainer">
    <div id="wheelPointer">▼</div>
    <canvas id="wheelCanvas"></canvas>
    <div id="centerOverlay">
      <div class="book" id="centerBook"></div>
      <div class="ref" id="centerRef"></div>
    </div>
  </div>

  <div id="statusText">請輸入姓名並鎖定名單</div>

  <script src="verseRefMap.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script>
(() => {
  "use strict";

  const nameInput  = document.getElementById("nameInput");
  const lockBtn    = document.getElementById("lockBtn");
  const startBtn   = document.getElementById("startBtn");
  const resetBtn   = document.getElementById("resetBtn");
  const pdfBtn     = document.getElementById("pdfBtn");
  const secondBtn  = document.getElementById("secondBtn");
  const viewerBtn  = document.getElementById("viewerBtn");
  const statusText = document.getElementById("statusText");

  const centerOverlay = document.getElementById("centerOverlay");
  const centerBook = document.getElementById("centerBook");
  const centerRef  = document.getElementById("centerRef");

  // Audio：只在真正 spin 時播放，避免游標/鎖定名單觸發
  const drumAudio = new Audio("audio/drum.mp3");
  drumAudio.preload = "auto";
  drumAudio.load();
  function playDrum(){
    try{
      drumAudio.currentTime = 0;
      const p = drumAudio.play();
      if (p && typeof p.catch === "function") p.catch(()=>{});
    }catch(_){}
  }

  const canvas = document.getElementById("wheelCanvas");
  const ctx = canvas.getContext("2d");

  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width  = Math.floor(rect.width  * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", () => {
    resizeCanvas();
    drawWheel();
  });

  const LS = {
    nameList: "BC128_nameList",
    usedNames: "BC128_usedNames",
    usedVerses: "BC128_usedVerses",
    logs: "BC128_drawLogs",
    state: "BC128_state",                 // idle | needSecond | needViewer
    selectedName: "BC128_selectedName",
    selectedVerse: "BC128_selectedVerse",
    rotation: "BC128_rotation",
    finished: "BC128_finished"
  };

  let nameList = [];
  let usedNames = [];
  let usedVerses = [];
  let selectedName = null;
  let selectedVerse = null;
  let appState = "idle";
  let roundFinished = false;
  let currentRotation = 0;

  // 轉速：加快 30%
  const SPIN_DURATION_MS = 3500;

  function setStatus(msg, isError=false){
    statusText.classList.toggle("error", !!isError);
    statusText.textContent = msg;
  }
  function normalizeRotation(r){
    const two = Math.PI * 2;
    r = r % two;
    if (r < 0) r += two;
    return r;
  }
  function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

  function parseNames(raw){
    return raw.trim().split(/[,、\\s]+/g).map(s=>s.trim()).filter(Boolean);
  }
  function hasDuplicate(arr){
    const s = new Set();
    for(const x of arr){ if(s.has(x)) return true; s.add(x); }
    return false;
  }
  function pad3(n){ return String(n).padStart(3, "0"); }
  function nowTimestamp(){
    const d = new Date();
    const Y = d.getFullYear();
    const M = String(d.getMonth()+1).padStart(2,'0');
    const D = String(d.getDate()).padStart(2,'0');
    const h = String(d.getHours()).padStart(2,'0');
    const m = String(d.getMinutes()).padStart(2,'0');
    const s = String(d.getSeconds()).padStart(2,'0');
    return `${Y}/${M}/${D} ${h}:${m}:${s}`;
  }
  function verseToBookRef(verse){
    const map = (typeof window.VERSE_REF_MAP === "object" && window.VERSE_REF_MAP) ? window.VERSE_REF_MAP : {};
    const ref = map[String(verse)] || "";
    const idx = ref.indexOf(" ");
    if(idx > 0) return { book: ref.slice(0, idx).trim(), ref: ref.slice(idx+1).trim() };
    return { book: ref.trim(), ref: "" };
  }

  function drawWheel(){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    ctx.clearRect(0,0,w,h);

    if(!nameList || nameList.length === 0){
      ctx.save();
      ctx.fillStyle = "rgba(90,58,0,.35)";
      ctx.font = "18px Noto Sans TC, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("請鎖定名單後開始", w/2, h/2);
      ctx.restore();
      return;
    }

    const cx = w/2, cy = h/2;
    const radius = Math.min(w,h)/2 - 12;
    const n = nameList.length;
    const arc = Math.PI*2 / n;

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(currentRotation);
    ctx.translate(-cx, -cy);

    for(let i=0;i<n;i++){
      const start = -Math.PI/2 + i*arc;
      const end = start + arc;

      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.arc(cx, cy, radius, start, end);
      ctx.closePath();
      ctx.fillStyle = (i % 2 === 0) ? "#fde7b5" : "#fcdca0";
      ctx.fill();

      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 2;
      ctx.stroke();

      const mid = start + arc/2;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(mid);
      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "#5b3a00";
      ctx.font = (n <= 4) ? "22px Noto Sans TC, sans-serif"
               : (n <= 8) ? "20px Noto Sans TC, sans-serif"
                          : "18px Noto Sans TC, sans-serif";
      ctx.fillText(nameList[i], radius - 18, 0);
      ctx.restore();
    }

    ctx.restore();
  }

  // index-based 命中核心
  function spinToIndex(targetIndex, clockwise){
    return new Promise(resolve => {
      if(!nameList || nameList.length === 0){ resolve(); return; }

      playDrum();

      const n = nameList.length;
      const arc = Math.PI*2 / n;

      const targetRotationBase = -(targetIndex * arc + arc/2);
      const extraSpins = 4 + Math.random()*2;
      const dir = clockwise ? 1 : -1;

      const endRotation = targetRotationBase + dir * extraSpins * Math.PI * 2;
      const startRotation = currentRotation;
      const startTime = performance.now();
      const dur = SPIN_DURATION_MS;

      function step(now){
        const t = Math.min(1, (now - startTime)/dur);
        const eased = easeOutCubic(t);
        currentRotation = startRotation + (endRotation - startRotation) * eased;
        drawWheel();
        if(t < 1){
          requestAnimationFrame(step);
        }else{
          currentRotation = normalizeRotation(currentRotation);
          localStorage.setItem(LS.rotation, String(currentRotation));
          drawWheel();
          resolve();
        }
      }
      requestAnimationFrame(step);
    });
  }

  function updateButtons(){
    if(!nameList || nameList.length < 2){
      startBtn.disabled = true;
      secondBtn.style.display = "none";
      viewerBtn.style.display = "none";
      return;
    }
    if(roundFinished){
      startBtn.disabled = true;
      secondBtn.style.display = "none";
      viewerBtn.style.display = "none";
      return;
    }
    if(appState === "idle"){
      startBtn.disabled = false;
      secondBtn.style.display = "none";
      viewerBtn.style.display = "none";
      return;
    }
    if(appState === "needSecond"){
      startBtn.disabled = true;
      secondBtn.style.display = "inline-block";
      secondBtn.classList.add("blinking");
      viewerBtn.style.display = "none";
      return;
    }
    if(appState === "needViewer"){
      startBtn.disabled = true;
      secondBtn.style.display = "none";
      viewerBtn.style.display = "inline-block";
      return;
    }
  }

  function persistState(){
    localStorage.setItem(LS.nameList, JSON.stringify(nameList));
    localStorage.setItem(LS.usedNames, JSON.stringify(usedNames));
    localStorage.setItem(LS.usedVerses, JSON.stringify(usedVerses));
    localStorage.setItem(LS.logs, localStorage.getItem(LS.logs) || "[]");
    localStorage.setItem(LS.state, appState);
    localStorage.setItem(LS.selectedName, selectedName ?? "");
    localStorage.setItem(LS.selectedVerse, selectedVerse ?? "");
    localStorage.setItem(LS.finished, roundFinished ? "1" : "0");

    if(nameList.length && usedNames.length >= nameList.length){
      roundFinished = true;
      appState = "idle";
      selectedName = null;
      selectedVerse = null;
      centerOverlay.style.display = "none";
      localStorage.setItem(LS.finished, "1");
      setStatus(`此輪轉盤已完成 ${nameList.length} 位的紅包抽籤，請按「全部歸零」重新開始。`, false);
      updateButtons();
    }
  }

  function loadState(){
    try{
      nameList = JSON.parse(localStorage.getItem(LS.nameList) || "[]");
      usedNames = JSON.parse(localStorage.getItem(LS.usedNames) || "[]");
      usedVerses = JSON.parse(localStorage.getItem(LS.usedVerses) || "[]");
    }catch(_){
      nameList = []; usedNames = []; usedVerses = [];
    }

    appState = localStorage.getItem(LS.state) || "idle";
    selectedName = (localStorage.getItem(LS.selectedName) || "").trim() || null;
    selectedVerse = (localStorage.getItem(LS.selectedVerse) || "").trim() || null;
    roundFinished = localStorage.getItem(LS.finished) === "1";

    const r = parseFloat(localStorage.getItem(LS.rotation) || "0");
    currentRotation = Number.isFinite(r) ? normalizeRotation(r) : 0;

    if(nameList && nameList.length) nameInput.value = nameList.join("、");

    if(roundFinished){
      setStatus(`此輪轉盤已完成 ${nameList.length} 位的紅包抽籤，請按「全部歸零」重新開始。`, false);
    }else if(appState === "idle"){
      setStatus(nameList.length ? `名單已鎖定，共 ${nameList.length} 位` : "請輸入姓名並鎖定名單", false);
    }else if(appState === "needSecond"){
      setStatus(`第 1 輪完成：抽中「${selectedName}」`, false);
    }else if(appState === "needViewer"){
      setStatus(`第 2 輪完成：抽中經句「${selectedVerse}」`, false);
      const br = verseToBookRef(selectedVerse);
      centerBook.textContent = br.book || "";
      centerRef.textContent  = br.ref || "";
      centerOverlay.style.display = (br.book || br.ref) ? "block" : "none";
    }

    updateButtons();
    drawWheel();
  }

  lockBtn.addEventListener("click", () => {
    const arr = parseNames(nameInput.value);
    if(arr.length === 0){ alert("請輸入姓名！"); return; }
    if(arr.length < 2){ alert("至少需要兩位姓名！"); return; }
    if(hasDuplicate(arr)){ alert("Oops, 有姓名被重複輸入了唷！"); return; }

    const prev = JSON.stringify(nameList);
    const next = JSON.stringify(arr);
    const listChanged = prev !== next;

    nameList = arr;

    if(listChanged){
      usedNames = [];
      usedVerses = [];
      localStorage.setItem(LS.logs, "[]");
      currentRotation = 0;
      localStorage.setItem(LS.rotation, "0");
      roundFinished = false;
    }

    appState = "idle";
    selectedName = null;
    selectedVerse = null;
    centerOverlay.style.display = "none";

    persistState();
    setStatus(`名單已鎖定，共 ${nameList.length} 位`, false);
    updateButtons();
    drawWheel();
  });

  startBtn.addEventListener("click", async () => {
    if(roundFinished){
      setStatus(`此輪轉盤已完成 ${nameList.length} 位的紅包抽籤，請按「全部歸零」重新開始。`, false);
      updateButtons();
      return;
    }
    if(!nameList || nameList.length < 2){ alert("請先鎖定名單（至少 2 位）！"); return; }
    if(appState !== "idle") return;

    centerOverlay.style.display = "none";

    const remaining = nameList.filter(n => !usedNames.includes(n));
    if(remaining.length === 0){
      roundFinished = true;
      persistState();
      return;
    }

    const winner = remaining[Math.floor(Math.random()*remaining.length)];
    const idx = nameList.indexOf(winner);

    selectedName = winner;
    selectedVerse = null;

    setStatus("第 1 輪：姓名輪盤抽籤中…", false);
    persistState();
    updateButtons();

    await spinToIndex(idx, false); // 第一輪逆時針

    setStatus(`第 1 輪完成：抽中「${winner}」`, false);
    appState = "needSecond";
    persistState();
    updateButtons();
  });

  secondBtn.addEventListener("click", async () => {
    if(appState !== "needSecond" || !selectedName) return;

    secondBtn.classList.remove("blinking");
    setStatus("第 2 輪：祝福經句輪盤抽籤中…", false);
    persistState();
    updateButtons();

    // 轉動期間不顯示中心書卷章節（避免作弊感）
    centerOverlay.style.display = "none";

    const idx = nameList.indexOf(selectedName);
    await spinToIndex(idx, true); // 第二輪順時針

    // 內部抽經句（001-128，不重複）
    const available = [];
    for(let i=1;i<=128;i++){
      const v = pad3(i);
      if(!usedVerses.includes(v)) available.push(v);
    }
    if(available.length === 0){
      usedVerses = [];
      localStorage.setItem(LS.usedVerses, "[]");
      for(let i=1;i<=128;i++) available.push(pad3(i));
    }
    selectedVerse = available[Math.floor(Math.random()*available.length)];
    usedVerses.push(selectedVerse);

    // 停下來後才顯示中心書卷章節（你要求）
    const br = verseToBookRef(selectedVerse);
    centerBook.textContent = br.book || "";
    centerRef.textContent  = br.ref || "";
    centerOverlay.style.display = (br.book || br.ref) ? "block" : "none";

    // 寫入 logs
    const logs = JSON.parse(localStorage.getItem(LS.logs) || "[]");
    logs.push({ time: nowTimestamp(), name: selectedName, verse: selectedVerse });
    localStorage.setItem(LS.logs, JSON.stringify(logs));

    // 完成此人
    if(!usedNames.includes(selectedName)) usedNames.push(selectedName);

    setStatus(`第 2 輪完成：抽中經句「${selectedVerse}」`, false);
    appState = "needViewer";
    persistState();
    updateButtons();
  });

  viewerBtn.addEventListener("click", () => {
    if(appState !== "needViewer" || !selectedName || !selectedVerse) return;
    const url = `viewer.html?name=${encodeURIComponent(selectedName)}&verse=${encodeURIComponent(selectedVerse)}`;
    location.href = url;
  });

  resetBtn.addEventListener("click", () => {
    Object.values(LS).forEach(k => localStorage.removeItem(k));
    location.href = location.pathname;
  });

  // PDF：影像式，完全不會中文亂碼；高解析避免模糊
  pdfBtn.addEventListener("click", async () => {
    try{
      const logs = JSON.parse(localStorage.getItem(LS.logs) || "[]");
      if(!logs.length){ alert("尚無抽籤紀錄！"); return; }

      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({ unit:"pt", format:"a4" });
      const pageW = 595.28, pageH = 841.89;

      const scale = 2.2;
      const canvasW = Math.floor(pageW * scale);
      const canvasH = Math.floor(pageH * scale);

      const off = document.createElement("canvas");
      off.width = canvasW;
      off.height = canvasH;
      const c = off.getContext("2d");

      const margin = Math.floor(40 * scale);
      const titleSize = Math.floor(22 * scale);
      const textSize  = Math.floor(16 * scale);
      const lh = Math.floor(22 * scale);

      function newPage(){
        c.clearRect(0,0,canvasW,canvasH);
        c.fillStyle = "#ffffff";
        c.fillRect(0,0,canvasW,canvasH);
        c.fillStyle = "#000000";
        c.textBaseline = "top";
        c.font = `${titleSize}px "Noto Sans TC", system-ui, sans-serif`;
        c.fillText("BlessingCards128 抽籤紀錄", margin, margin);
        c.font = `${textSize}px "Noto Sans TC", system-ui, sans-serif`;
        return margin + Math.floor(50*scale);
      }

      function wrapText(ctx, text, x, y, maxW, lineH){
        let line = "";
        for(const ch of text){
          const test = line + ch;
          if(ctx.measureText(test).width > maxW && line){
            ctx.fillText(line, x, y);
            y += lineH;
            line = ch;
          }else{
            line = test;
          }
        }
        if(line){
          ctx.fillText(line, x, y);
          y += lineH;
        }
        return y;
      }

      let y = newPage();
      let pageIndex = 0;

      for(const log of logs){
        const br = verseToBookRef(log.verse);
        const refStr = (br.book && br.ref) ? `${br.book} ${br.ref}` : (br.book || br.ref || "");
        const line = `[${log.time}] ${log.name}｜抽中經句：${log.verse}${refStr ? `（${refStr}）` : ""}`;

        // 若剩餘空間不足 3 行，先換頁（避免半行被切）
        if(y > canvasH - margin - 3*lh){
          const img = off.toDataURL("image/png");
          if(pageIndex > 0) doc.addPage();
          doc.addImage(img, "PNG", 0, 0, pageW, pageH);
          pageIndex++;
          y = newPage();
        }

        y = wrapText(c, line, margin, y, canvasW - margin*2, lh) + Math.floor(6*scale);
      }

      const img = off.toDataURL("image/png");
      if(pageIndex > 0) doc.addPage();
      doc.addImage(img, "PNG", 0, 0, pageW, pageH);

      doc.save("BlessingCards128_抽籤紀錄.pdf");
    }catch(e){
      console.error(e);
      alert("PDF 產生失敗（可能是瀏覽器記憶體不足或權限限制）。請查看 Console 錯誤訊息。");
      setStatus("PDF 產生失敗：請查看 Console 錯誤訊息。", true);
    }
  });

  resizeCanvas();
  loadState();
})();
</script>
</body>
</html>
