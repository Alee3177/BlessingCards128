<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<title>祝福經句紅包（應許等您拿）</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="preload" as="image" href="logo3524.png">
<link rel="preload" as="audio" href="audio/drum.mp3">
<link rel="preload" as="audio" href="audio/win.mp3">

<style>
  body{
    background:#fff8e7;
    font-family:"Noto Sans TC", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI";
    text-align:center;
    padding:20px;
    color:#5b3a00;
  }
  h1{ color:#b07500; margin: 6px 0 10px; font-size: 26px; }
  .logo{ width:120px; margin: 8px auto 12px; display:block; }

  input{
    width: 300px;
    max-width: 90vw;
    padding: 10px 12px;
    font-size: 18px;
    border-radius: 8px;
    border: 1px solid #bf8a3e;
    margin-bottom: 10px;
  }

  .btn{
    background:#f7c76c;
    border:none;
    padding:10px 18px;
    border-radius:22px;
    font-size:16px;
    color:#5b3a00;
    cursor:pointer;
    margin:4px;
  }
  .btn:hover{ background:#f3b84f; }
  .btn:disabled{ opacity:.45; cursor:not-allowed; }

  #wheelWrap{
    position:relative;
    width:360px;
    height:360px;
    margin:18px auto 10px;
  }
  canvas{ width:360px; height:360px; }

  #status{
    margin-top:10px;
    font-size:18px;
    color:#a56b00;
    min-height: 28px;
    white-space: pre-line;
  }
  #status.error{
    color:#c0392b;
    font-weight:700;
  }

  /* 第二輪按鈕閃爍 */
  @keyframes blink { 0%{opacity:1} 50%{opacity:.25} 100%{opacity:1} }
  .blinking { animation: blink 1s infinite; }
</style>
</head>

<body>

<h1>祝福經句紅包（應許等您拿）</h1>
<img src="logo3524.png" class="logo" alt="logo" loading="eager" decoding="async" />

<input id="nameInput" placeholder="請輸入姓名（用 , 或 、 分隔）" autocomplete="off" />
<br>
<button class="btn" id="lockBtn" onclick="lockList()">鎖定名單</button>
<button class="btn" id="startBtn" onclick="startFirstRound()" disabled>開始抽姓名 + 經句</button>
<button class="btn" id="resetBtn" onclick="resetAll()">全部歸零</button>
<button class="btn" id="pdfBtn" onclick="exportPDF()">抽籤紀錄 PDF</button>

<br>
<button class="btn" id="secondBtn" onclick="startSecondRound()" style="display:none;">抽紅包（第二輪）</button>
<button class="btn" id="viewerBtn" onclick="gotoViewer()" style="display:none;">看紅包內容</button>

<div id="wheelWrap">
  <canvas id="wheel" width="360" height="360"></canvas>
</div>

<div id="status">請輸入姓名並鎖定名單</div>

<!-- 經文對照表 -->
<script src="verseRefMap.js"></script>

<!-- 若你有 font_base64.js（window.PDF_FONT.normal），可取消註解讓 PDF 最穩 -->
<!-- <script src="font_base64.js"></script> -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<audio id="drum" src="audio/drum.mp3" preload="auto"></audio>
<audio id="win"  src="audio/win.mp3"  preload="auto"></audio>

<script>
/* =========================================================
   v7.1 Stable Core (Fixes)
   1) viewer 回來可繼續下一位
   2) 第二輪書卷/章節：停下才顯示（不作弊）
   3) 指針永遠命中中獎 slice：角度反推校驗 + 自動微調
   4) 不會自己播 drum：只有按抽籤才播
   5) 不需要再按鎖定名單才能玩完一輪
========================================================= */

const canvas   = document.getElementById("wheel");
const ctx      = canvas.getContext("2d");
const statusEl = document.getElementById("status");

const nameInput= document.getElementById("nameInput");
const lockBtn  = document.getElementById("lockBtn");
const startBtn = document.getElementById("startBtn");
const resetBtn = document.getElementById("resetBtn");
const pdfBtn   = document.getElementById("pdfBtn");

const secondBtn= document.getElementById("secondBtn");
const viewerBtn= document.getElementById("viewerBtn");

const drum     = document.getElementById("drum");
const winAudio = document.getElementById("win");

const C = 180;
const R = 168;
const START0 = -Math.PI/2;

// pointer triangle
const POINTER_LEN = 18;
const POINTER_W   = 18;

// State
let locked = false;
let spinning = false;

// name wheel data
let nameList = [];
let remainingIndices = [];   // 尚未被抽第一輪的 index
let completedNames = [];     // 已完成第二輪的人（用來做結束判斷）

// second round
let usedVerses = [];         // 同輪不重複
let selectedName = null;
let selectedVerse = null;

// stage: idle / afterFirst / afterSecond
let stage = "idle";

// render
let currentRotation = 0;

// completion notice after viewer return
let completionPending = false;

// ---------- UI helpers ----------
function setStatus(text, isError=false){
  statusEl.textContent = text;
  statusEl.classList.toggle("error", !!isError);
}
function parseNames(raw){
  return raw.split(/[,、\s]+/).map(s=>s.trim()).filter(Boolean);
}
function hasDuplicate(arr){
  return new Set(arr).size !== arr.length;
}
function playDrum(){
  try { drum.currentTime = 0; drum.play().catch(()=>{}); } catch(_){}
}
function playWin(){
  try { winAudio.currentTime = 0; winAudio.play().catch(()=>{}); } catch(_){}
}

// ---------- LocalStorage ----------
function saveLS(){
  localStorage.setItem("BC128_v71_locked", locked ? "1":"0");
  localStorage.setItem("BC128_v71_nameList", JSON.stringify(nameList));
  localStorage.setItem("BC128_v71_remaining", JSON.stringify(remainingIndices));
  localStorage.setItem("BC128_v71_completed", JSON.stringify(completedNames));
  localStorage.setItem("BC128_v71_usedVerses", JSON.stringify(usedVerses));
  localStorage.setItem("BC128_v71_stage", stage);
  localStorage.setItem("BC128_v71_selectedName", selectedName ?? "");
  localStorage.setItem("BC128_v71_selectedVerse", selectedVerse ?? "");
  localStorage.setItem("BC128_v71_rotation", String(currentRotation));
  localStorage.setItem("BC128_v71_completionPending", completionPending ? "1":"0");
  localStorage.setItem("BC128_v71_logs", localStorage.getItem("BC128_v71_logs") || "[]");
}
function loadLS(){
  try{
    locked = localStorage.getItem("BC128_v71_locked") === "1";
    nameList = JSON.parse(localStorage.getItem("BC128_v71_nameList") || "[]");
    remainingIndices = JSON.parse(localStorage.getItem("BC128_v71_remaining") || "[]");
    completedNames = JSON.parse(localStorage.getItem("BC128_v71_completed") || "[]");
    usedVerses = JSON.parse(localStorage.getItem("BC128_v71_usedVerses") || "[]");
    stage = localStorage.getItem("BC128_v71_stage") || "idle";
    selectedName = localStorage.getItem("BC128_v71_selectedName") || null;
    selectedVerse = localStorage.getItem("BC128_v71_selectedVerse") || null;
    currentRotation = Number(localStorage.getItem("BC128_v71_rotation") || "0") || 0;
    completionPending = localStorage.getItem("BC128_v71_completionPending") === "1";
  }catch(e){}
}

// ---------- Drawing ----------
function drawPointer(){
  const tipX = C;
  const tipY = C - R - 2;
  const baseY = tipY - POINTER_LEN;
  const halfW = POINTER_W / 2;

  ctx.save();
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.moveTo(tipX, tipY);
  ctx.lineTo(tipX - halfW, baseY);
  ctx.lineTo(tipX + halfW, baseY);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function drawWheel(items, rotation, opts={}){
  const { labels=true, centerLines=null } = opts;

  ctx.clearRect(0,0,360,360);

  ctx.save();
  ctx.translate(C,C);
  ctx.rotate(rotation);
  ctx.translate(-C,-C);

  const n = items.length;
  if(n>0){
    const arc = Math.PI*2/n;
    for(let i=0;i<n;i++){
      const start = START0 + i*arc;
      const end = start + arc;

      ctx.beginPath();
      ctx.moveTo(C,C);
      ctx.arc(C,C,R,start,end);
      ctx.closePath();
      ctx.fillStyle = (i%2===0) ? "#fce8b8" : "#fde2a7";
      ctx.fill();

      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 2;
      ctx.stroke();

      if(labels){
        ctx.save();
        ctx.translate(C,C);
        ctx.rotate(start + arc/2);
        ctx.textAlign="right";
        ctx.font="20px 'Noto Sans TC'";
        ctx.fillStyle="#5b3a00";
        ctx.fillText(items[i], R-14, 8);
        ctx.restore();
      }
    }
  }
  ctx.restore();

  // center text AFTER wheel rotation (not rotating with wheel)
  if(centerLines && centerLines.length){
    ctx.save();
    ctx.textAlign="center";
    ctx.fillStyle="#7a4d00";
    ctx.font="18px 'Noto Sans TC'";
    const y0 = C - 8;
    if(centerLines.length === 1){
      ctx.fillText(centerLines[0], C, C+6);
    }else{
      ctx.fillText(centerLines[0], C, y0);
      ctx.fillText(centerLines[1], C, y0 + 24);
    }
    ctx.restore();
  }

  drawPointer();
}

// ---------- Exact index mapping under pointer ----------
function mod2pi(x){
  const t = x % (2*Math.PI);
  return t < 0 ? t + 2*Math.PI : t;
}

// pointer at angle START0 (12 o'clock). Slice i covers [START0 + i*arc + rot, START0 + (i+1)*arc + rot)
function indexAtPointer(rot, n){
  const arc = 2*Math.PI/n;
  // pointer inside slice when -rot mod 2pi in [i*arc, (i+1)*arc)
  const s = mod2pi(-rot);
  let idx = Math.floor(s / arc);
  if(idx < 0) idx = 0;
  if(idx >= n) idx = n-1;
  return idx;
}

// push rotation away from boundaries by >=10px at rim
function pushAwayFromBoundary(rot, n){
  const arc = 2*Math.PI/n;
  const marginAngle = 10 / R; // ~10px
  const s = mod2pi(-rot);
  const i = Math.floor(s / arc);
  const left = i*arc;
  const right = (i+1)*arc;
  const distL = s - left;
  const distR = right - s;

  let newRot = rot;
  if(distL < marginAngle){
    const delta = (marginAngle - distL) + 0.0005;
    newRot -= delta; // because s = -rot, decreasing rot increases s
  }else if(distR < marginAngle){
    const delta = (marginAngle - distR) + 0.0005;
    newRot += delta;
  }
  return newRot;
}

// compute a final rotation that guarantees winner index is under pointer, and not on boundary
function computeFinalRotationGuaranteed(n, winnerIndex){
  const arc = 2*Math.PI/n;

  // base: center of slice at pointer
  let rot = -(winnerIndex*arc + arc/2);

  // add mild jitter but keep in same slice safely
  const marginAngle = 10 / R;
  const maxJitter = Math.max(0, (arc/2) - marginAngle*1.6);
  const jitter = (Math.random()*2 - 1) * maxJitter;
  rot += jitter;

  // verify & adjust until index matches (should converge fast)
  let guard = 0;
  while(indexAtPointer(rot, n) !== winnerIndex && guard < 20){
    // if off by one, nudge by arc in correct direction
    const cur = indexAtPointer(rot, n);
    const diff = (winnerIndex - cur + n) % n;
    if(diff === 1){
      rot -= arc * 0.9;
    }else if(diff === n-1){
      rot += arc * 0.9;
    }else{
      // fallback: force back to center
      rot = -(winnerIndex*arc + arc/2);
    }
    guard++;
  }

  // ensure not near boundary
  rot = pushAwayFromBoundary(rot, n);

  // final re-verify (hard guarantee)
  guard = 0;
  while(indexAtPointer(rot, n) !== winnerIndex && guard < 20){
    rot -= 0.0007; // tiny nudge
    guard++;
  }
  return rot;
}

// ---------- Spin animation ----------
function spinToWinner(items, winnerIndex, direction, durationMs, opts={}){
  return new Promise(resolve=>{
    const n = items.length;
    if(n < 2){ resolve(); return; }

    const extraSpins = 4 + Math.random()*1.5;
    const dir = (direction === "cw") ? 1 : -1;

    const target = computeFinalRotationGuaranteed(n, winnerIndex);
    const final = target + dir * extraSpins * 2*Math.PI;

    const startRot = currentRotation;
    const startTime = performance.now();
    const duration = durationMs;

    function easeOutQuart(t){ return 1 - Math.pow(1-t, 4); }

    function frame(now){
      const t = Math.min((now - startTime)/duration, 1);
      const eased = easeOutQuart(t);

      currentRotation = startRot + (final - startRot) * eased;
      drawWheel(items, currentRotation, opts);

      if(t < 1){
        requestAnimationFrame(frame);
      }else{
        // keep the exact final (no snap redraw)
        currentRotation = final;
        drawWheel(items, currentRotation, opts);
        resolve();
      }
    }
    requestAnimationFrame(frame);
  });
}

// ---------- Logs ----------
function pushLog(line){
  const logs = JSON.parse(localStorage.getItem("BC128_v71_logs") || "[]");
  logs.push(line);
  localStorage.setItem("BC128_v71_logs", JSON.stringify(logs));
}
function formatTS(d){
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth()+1).padStart(2,"0");
  const dd = String(d.getDate()).padStart(2,"0");
  const HH = String(d.getHours()).padStart(2,"0");
  const MM = String(d.getMinutes()).padStart(2,"0");
  const SS = String(d.getSeconds()).padStart(2,"0");
  return `${yyyy}/${mm}/${dd} ${HH}:${MM}:${SS}`;
}
function splitBookChapter(ref){
  if(!ref) return ["",""];
  const idx = ref.lastIndexOf(" ");
  if(idx < 0) return [ref,""];
  return [ref.slice(0, idx).trim(), ref.slice(idx+1).trim()];
}

// ---------- UI state ----------
function refreshUI(){
  if(locked && nameList.length >= 2){
    nameInput.value = nameList.join("、");
    // start is enabled only when idle & not spinning & there are remaining indices
    startBtn.disabled = spinning || (stage !== "idle") || (remainingIndices.length === 0);
  }else{
    startBtn.disabled = true;
  }

  lockBtn.disabled = spinning;
  resetBtn.disabled = spinning;
  pdfBtn.disabled = spinning;

  if(stage === "afterFirst"){
    secondBtn.style.display = "inline-block";
    secondBtn.classList.add("blinking");
    viewerBtn.style.display = "none";
  }else if(stage === "afterSecond"){
    secondBtn.style.display = "none";
    secondBtn.classList.remove("blinking");
    viewerBtn.style.display = "inline-block";
  }else{
    secondBtn.style.display = "none";
    secondBtn.classList.remove("blinking");
    viewerBtn.style.display = "none";
  }
}

// ---------- Lock list ----------
function lockList(){
  if(spinning) return;

  const raw = nameInput.value.trim();
  if(!raw){
    alert("請輸入姓名");
    return;
  }
  const names = parseNames(raw);
  if(hasDuplicate(names)){
    alert("Oops, 有姓名被重複輸入了唷！");
    return;
  }
  if(names.length < 2){
    alert("至少需要兩位");
    return;
  }

  // 若同一輪名單相同且已鎖定，直接忽略（避免你誤按又被洗掉狀態）
  if(locked && JSON.stringify(names) === JSON.stringify(nameList) && remainingIndices.length > 0){
    setStatus(`名單已鎖定（${nameList.length} 位）`);
    refreshUI();
    return;
  }

  // Start a fresh round
  locked = true;
  nameList = names.slice();
  remainingIndices = nameList.map((_,i)=>i);
  completedNames = [];
  usedVerses = [];
  selectedName = null;
  selectedVerse = null;
  stage = "idle";
  completionPending = false;
  currentRotation = 0;

  drawWheel(nameList, currentRotation, {labels:true});
  setStatus(`名單已鎖定（${nameList.length} 位）`);

  saveLS();
  refreshUI();
}

// ---------- First round ----------
async function startFirstRound(){
  if(spinning) return;
  if(!locked || nameList.length < 2){
    alert("請先鎖定名單");
    return;
  }
  if(stage !== "idle"){
    alert("請先完成第二輪（抽紅包），再進行下一位。");
    return;
  }
  if(remainingIndices.length === 0){
    setStatus(`此輪轉盤已完成 ${nameList.length} 位的紅包抽籤，請按「全部歸零」重新開始。`);
    refreshUI();
    return;
  }

  spinning = true;
  refreshUI();

  // choose winner from remaining
  const pickPos = Math.floor(Math.random()*remainingIndices.length);
  const winIndex = remainingIndices[pickPos];
  selectedName = nameList[winIndex];
  selectedVerse = null;

  // IMPORTANT: remove immediately so next person is different even if user refreshes
  remainingIndices.splice(pickPos, 1);

  setStatus("第 1 輪：姓名輪盤抽籤中…");
  playDrum();

  await spinToWinner(nameList, winIndex, "ccw", 5000, {labels:true});

  setStatus(`第 1 輪完成：抽中「${selectedName}」`);
  stage = "afterFirst";

  saveLS();
  spinning = false;
  refreshUI();
}

// ---------- Second round ----------
async function startSecondRound(){
  if(spinning) return;
  if(stage !== "afterFirst" || !selectedName){
    alert("請先完成第一輪");
    return;
  }

  spinning = true;
  refreshUI();
  secondBtn.classList.remove("blinking");

  const map = window.VERSE_REF_MAP || {};
  const allVerses = Object.keys(map);
  if(allVerses.length === 0){
    setStatus("找不到 VERSE_REF_MAP（請確認 verseRefMap.js 已載入）", true);
    spinning = false;
    refreshUI();
    return;
  }

  const available = allVerses.filter(v => !usedVerses.includes(v));
  if(available.length === 0){
    setStatus("128 個經句已全抽完（請按全部歸零）", true);
    spinning = false;
    refreshUI();
    return;
  }

  // truth: pick verse first, but DO NOT show book/chapter until stop
  selectedVerse = available[Math.floor(Math.random()*available.length)];
  usedVerses.push(selectedVerse);

  const winnerIndex = nameList.indexOf(selectedName);
  setStatus("第 2 輪：祝福經句輪盤抽籤中…");
  playDrum();

  // spin (labels hidden, NO center text during spin)
  await spinToWinner(nameList, winnerIndex, "cw", 5000, {labels:false, centerLines:null});

  // after stop: show center book/chapter
  const ref = map[selectedVerse] || "";
  const [book, chapter] = splitBookChapter(ref);
  drawWheel(nameList, currentRotation, {labels:false, centerLines: (book||chapter) ? [book||"", chapter||""] : null});

  setStatus(`第 2 輪完成：抽中經句「${selectedVerse}」`);

  if(!completedNames.includes(selectedName)) completedNames.push(selectedName);

  // one-line log
  const ts = formatTS(new Date());
  const line = `[${ts}] ${selectedName}｜姓名模式｜抽中經句：${selectedVerse}（${ref}）`;
  pushLog(line);

  stage = "afterSecond";

  // if this was the last person, postpone completion message until user returns from viewer
  if(completedNames.length >= nameList.length){
    completionPending = true;
  }

  saveLS();
  spinning = false;
  refreshUI();
}

// ---------- Viewer ----------
function gotoViewer(){
  if(stage !== "afterSecond" || !selectedName || !selectedVerse){
    alert("尚未完成第二輪");
    return;
  }
  // viewer 內自己處理 win.mp3/confetti
  const url = `viewer.html?name=${encodeURIComponent(selectedName)}&verse=${encodeURIComponent(selectedVerse)}`;
  window.location.href = url;
}

// ---------- Reset ----------
function resetAll(){
  // clear v7.1 keys
  [
    "BC128_v71_locked","BC128_v71_nameList","BC128_v71_remaining","BC128_v71_completed",
    "BC128_v71_usedVerses","BC128_v71_stage","BC128_v71_selectedName","BC128_v71_selectedVerse",
    "BC128_v71_rotation","BC128_v71_completionPending","BC128_v71_logs"
  ].forEach(k=>localStorage.removeItem(k));

  locked=false; spinning=false;
  nameList=[]; remainingIndices=[]; completedNames=[];
  usedVerses=[]; selectedName=null; selectedVerse=null;
  stage="idle"; completionPending=false; currentRotation=0;

  nameInput.value="";
  setStatus("請輸入姓名並鎖定名單");
  ctx.clearRect(0,0,360,360);
  drawPointer();
  refreshUI();
}

// ---------- PDF ----------
async function exportPDF(){
  try{
    const logs = JSON.parse(localStorage.getItem("BC128_v71_logs") || "[]");
    if(!logs.length){
      setStatus("尚無抽籤紀錄可匯出。", true);
      return;
    }

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit:"pt", format:"a4" });

    // Prefer embedded font if you use font_base64.js
    if(window.PDF_FONT && window.PDF_FONT.normal){
      try{
        doc.addFileToVFS("NotoSansTC.ttf", window.PDF_FONT.normal);
        doc.addFont("NotoSansTC.ttf","NotoSansTC","normal");
        doc.setFont("NotoSansTC","normal");
      }catch(e){}
    }

    doc.setFontSize(16);
    doc.text("BlessingCards128 抽籤紀錄", 40, 44);

    doc.setFontSize(12);
    let y = 70;
    const lh = 18;

    for(const line of logs){
      const wrapped = doc.splitTextToSize(line, 515);
      doc.text(wrapped, 40, y);
      y += wrapped.length * lh;
      if(y > 770){
        doc.addPage();
        y = 50;
      }
    }

    doc.save("BlessingCards128_抽籤紀錄_v7.1.pdf");
    setStatus("PDF 已產生並下載。");
  }catch(err){
    console.error(err);
    setStatus("PDF 產生失敗：請查看 Console 錯誤訊息。", true);
  }
}

// ---------- Init ----------
(function init(){
  loadLS();

  // Restore wheel
  if(locked && nameList.length >= 2){
    nameInput.value = nameList.join("、");
    drawWheel(nameList, currentRotation, {labels:true});
  }else{
    ctx.clearRect(0,0,360,360);
    drawPointer();
  }

  // KEY FIX: Coming back from viewer
  // If we were afterSecond, auto-advance to next person (idle) so start button is enabled.
  if(locked && stage === "afterSecond"){
    // If round finished, show completion message ONLY now (no alert)
    if(completionPending && completedNames.length >= nameList.length){
      setStatus(`此輪轉盤已完成 ${nameList.length} 位的紅包抽籤，請按「全部歸零」重新開始。`);
      // lock further start
      stage = "idle";
      completionPending = false;
    }else{
      // continue next person
      stage = "idle";
      selectedName = null;
      selectedVerse = null;
      setStatus(`可抽下一位（剩餘 ${remainingIndices.length} 位）`);
    }
    saveLS();
  }else{
    // status for other states
    if(locked && nameList.length >= 2){
      if(remainingIndices.length === 0 && completedNames.length >= nameList.length){
        setStatus(`此輪轉盤已完成 ${nameList.length} 位的紅包抽籤，請按「全部歸零」重新開始。`);
      }else if(stage === "afterFirst"){
        setStatus(`第 1 輪完成：抽中「${selectedName || ""}」`);
      }else if(stage === "afterSecond"){
        setStatus(`第 2 輪完成：抽中經句「${selectedVerse || ""}」`);
      }else{
        setStatus(`名單已載入（${nameList.length} 位），可開始抽姓名 + 經句`);
      }
    }
  }

  refreshUI();
})();
</script>

</body>
</html>
