<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ç¥ç¦ç¶“å¥ç´…åŒ…ï¼ˆæ‡‰è¨±ç­‰æ‚¨æ‹¿ï¼‰</title>
  <style>
    :root{
      --bg:#fff8e7;
      --text:#5b3a00;
      --gold:#f7c76c;
      --gold2:#f3b84f;
      --border:#bf8a3e;
      --warn:#a56b00;
      --err:#c0392b;
    }
    body{
      background:var(--bg);
      font-family:"Noto Sans TC", system-ui, -apple-system, "Segoe UI", Arial, sans-serif;
      text-align:center;
      padding:22px;
      color:var(--text);
    }
    h1{ color:#b07500; font-size:26px; margin:0 0 10px; }
    .logo{ width:120px; margin:0 0 14px; }

    #nameInput{
      width:280px; padding:10px; font-size:18px;
      border-radius:8px; border:1px solid var(--border);
      margin-bottom:12px;
      background:#fff;
    }

    .btn{
      background:var(--gold);
      border:none;
      padding:12px 22px;
      border-radius:25px;
      font-size:18px;
      color:var(--text);
      cursor:pointer;
      margin:6px;
      transition:background .15s ease;
    }
    .btn:hover{ background:var(--gold2); }
    .btn:disabled{ opacity:.45; cursor:not-allowed; }

    @keyframes blink { 0%{opacity:1} 50%{opacity:.25} 100%{opacity:1} }
    .blinking{ animation:blink 1s infinite; }

    #wheelContainer{
      position:relative;
      width:380px; height:380px;
      margin:22px auto;
    }
    #wheelCanvas{ width:380px; height:380px; }
    #wheelPointer{
      position:absolute;
      top:-26px;
      left:50%;
      transform:translateX(-50%);
      font-size:44px;
      color:red;
      z-index:20;
      line-height:1;
      user-select:none;
      pointer-events:none;
    }
    #centerLabel{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
      user-select:none;
      text-align:center;
      padding:0 38px;
      color:#5b3a00;
      font-weight:700;
      font-size:20px;
      text-shadow:0 1px 0 rgba(255,255,255,.75);
      display:none;
    }
    #centerLabel .line1{ display:block; font-size:20px; }
    #centerLabel .line2{ display:block; margin-top:6px; font-size:20px; }

    #statusText{
      font-size:20px;
      margin-top:8px;
      color:var(--warn);
      white-space:pre-line;
    }
    #statusText.error{ color:var(--err); font-weight:700; }
  </style>
</head>
<body>

  <h1>ç¥ç¦ç¶“å¥ç´…åŒ…ï¼ˆæ‡‰è¨±ç­‰æ‚¨æ‹¿ï¼‰</h1>
  <img src="logo3524.png" class="logo" alt="logo">

  <input id="nameInput" placeholder="è«‹è¼¸å…¥å§“åï¼ˆå¯ç”¨é€—è™Ÿã€é “è™Ÿã€ç©ºç™½åˆ†éš”ï¼‰"><br>

  <button id="lockBtn" class="btn">é–å®šåå–®</button>
  <button id="startBtn" class="btn">é–‹å§‹æŠ½å§“å + ç¶“å¥</button>
  <button id="resetBtn" class="btn">å…¨éƒ¨æ­¸é›¶</button>
  <button id="pdfBtn" class="btn">æŠ½ç±¤ç´€éŒ„ PDF</button>

  <button id="secondBtn" class="btn" style="display:none;">æŠ½ç´…åŒ…ï¼ˆç¬¬äºŒè¼ªï¼‰</button>
  <button id="viewerBtn" class="btn" style="display:none;">çœ‹ç´…åŒ…å…§å®¹</button>

  <div id="wheelContainer">
    <div id="wheelPointer">â–¼</div>
    <canvas id="wheelCanvas" width="380" height="380"></canvas>
    <div id="centerLabel">
      <div>
        <span class="line1" id="centerLine1"></span>
        <span class="line2" id="centerLine2"></span>
      </div>
    </div>
  </div>

  <div id="statusText">è«‹è¼¸å…¥å§“åä¸¦é–å®šåå–®</div>

  <script src="verseRefMap.js"></script>

  <script>
  /* =========================================================
     BlessingCards128  index.html  v8.5.0 Stable Final
     - åƒ…è®Šæ›´ï¼šè½‰é€Ÿ +30%ï¼ˆåŒ drum æ™‚é•·ï¼Œè½‰æ›´å¤šåœˆï¼‰
     - è·¨è¼ªç´¯ç©ï¼šé–å®šåå–®é–‹å§‹ä¸‹ä¸€è¼ªä¸æ¸…ç©º logsï¼›å…¨éƒ¨æ­¸é›¶æ‰æ¸…ç©º
  ========================================================== */

  const VERSION = "v8.5.0";

  // storage keys
  const K_LIST  = "bc_nameList";
  const K_USEDN = "bc_usedNames";
  const K_USEDV = "bc_usedVerses";
  const K_LOGS  = "bc_drawLogs";
  const K_FIN   = "bc_roundFinished";
  const K_LAST  = "bc_lastResult";

  const nameInput = document.getElementById("nameInput");
  const lockBtn   = document.getElementById("lockBtn");
  const startBtn  = document.getElementById("startBtn");
  const resetBtn  = document.getElementById("resetBtn");
  const pdfBtn    = document.getElementById("pdfBtn");
  const secondBtn = document.getElementById("secondBtn");
  const viewerBtn = document.getElementById("viewerBtn");
  const statusText= document.getElementById("statusText");

  const canvas = document.getElementById("wheelCanvas");
  const ctx = canvas.getContext("2d");

  const centerLabel = document.getElementById("centerLabel");
  const centerLine1 = document.getElementById("centerLine1");
  const centerLine2 = document.getElementById("centerLine2");

  const CENTER = 190;
  const RADIUS = 180;

  let nameList = [];
  let locked = false;

  let usedNames = [];
  let usedVerses = [];

  let selectedName = null;
  let selectedVerse = null;

  let isSpinning = false;
  let stage = 0; // 0 idle, 1 after round1, 2 after round2 ready viewer

  // keep a stable wheel angle (no redraw drift across steps)
  let wheelAngle = 0;

  function nowTS(){
    const d = new Date();
    const Y = d.getFullYear();
    const M = String(d.getMonth()+1).padStart(2,"0");
    const D = String(d.getDate()).padStart(2,"0");
    const h = String(d.getHours()).padStart(2,"0");
    const m = String(d.getMinutes()).padStart(2,"0");
    const s = String(d.getSeconds()).padStart(2,"0");
    return `${Y}/${M}/${D} ${h}:${m}:${s}`;
  }

  function setStatus(msg, isError=false){
    statusText.classList.toggle("error", !!isError);
    statusText.textContent = msg;
  }

  function showCenter(book, chap){
    centerLine1.textContent = book || "";
    centerLine2.textContent = chap || "";
    centerLabel.style.display = "flex";
  }
  function hideCenter(){
    centerLabel.style.display = "none";
    centerLine1.textContent = "";
    centerLine2.textContent = "";
  }

  function playDrum(){
    // åªåœ¨çœŸæ­£é–‹å§‹ spin æ‰æ’­æ”¾
    try{
      const a = new Audio("audio/drum.mp3");
      a.preload = "auto";
      a.play().catch(()=>{});
    }catch(e){}
  }

  function ensureLogsInit(){
    if(!localStorage.getItem(K_LOGS)){
      localStorage.setItem(K_LOGS, "[]");
    }
  }

  function parseNames(raw){
    // æ”¯æ´ï¼šé€—è™Ÿã€é “è™Ÿã€ç©ºç™½
    const arr = raw.split(/[,ï¼Œã€\s]+/).map(x=>x.trim()).filter(Boolean);
    return arr;
  }

  function hasDup(arr){
    const s = new Set();
    for(const x of arr){
      if(s.has(x)) return true;
      s.add(x);
    }
    return false;
  }

  function drawWheel(items){
    ctx.clearRect(0,0,380,380);
    if(!items || items.length===0) return;

    const count = items.length;
    const arc = Math.PI*2 / count;

    for(let i=0;i<count;i++){
      const start = arc*i - Math.PI/2;
      const end   = start + arc;

      ctx.beginPath();
      ctx.fillStyle = (i%2===0) ? "#fde7b5" : "#fcdca0";
      ctx.moveTo(CENTER, CENTER);
      ctx.arc(CENTER, CENTER, RADIUS, start, end);
      ctx.closePath();
      ctx.fill();

      // separator lines
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 2;
      ctx.stroke();

      // text
      ctx.save();
      ctx.translate(CENTER, CENTER);
      const mid = start + arc/2;
      ctx.rotate(mid);
      ctx.textAlign = "right";
      ctx.font = "22px Noto Sans TC";
      ctx.fillStyle = "#5b3a00";
      ctx.fillText(items[i], RADIUS-22, 10);
      ctx.restore();
    }
  }

  function renderAtAngle(items, angle){
    ctx.save();
    ctx.clearRect(0,0,380,380);
    ctx.translate(CENTER, CENTER);
    ctx.rotate(angle);
    ctx.translate(-CENTER, -CENTER);
    drawWheel(items);
    ctx.restore();
  }

  function easeOutCubic(t){ return 1 - Math.pow(1-t, 3); }

  // æŒ‡é‡åœ¨ä¸Šæ–¹æœä¸‹ï¼ˆè¦–è¦ºï¼‰ï¼Œä»¥ã€Œä¸Šæ–¹ç‚º0ã€å®šç¾©
  // æˆ‘å€‘è®“ä¸­ç slice ä¸­å¿ƒè§’è½åœ¨æŒ‡é‡ä¸‹æ–¹ï¼ˆä¸Šæ–¹æŒ‡é‡â†’ slice center angle = 0ï¼‰
  // é€™è£¡æ¡ç”¨ index-based ç›´ç®—ï¼Œä¸¦åŠ å…¥å®‰å…¨ margin é¿å…è½ç·š
  function computeTargetAngle(count, index, clockwise){
    const arc = (Math.PI*2)/count;

    // slice center (with 0 at top)
    const centerAtTop = index * arc + arc/2;

    // safe margin (10px) -> convert to radians (approx)
    // angle margin = 10 / RADIUS
    const margin = 10 / RADIUS;

    // push slightly away from boundaries toward slice center
    const safeCenter = centerAtTop + (Math.random()*2-1) * (Math.max(0, arc/2 - margin) * 0.15);

    // Our wheel drawing starts at -90Â° so that slice 0 begins at top.
    // To bring slice center to pointer top, wheelAngle should be: -safeCenter
    // Add multiple spins for animation
    const dir = clockwise ? 1 : -1;

    // ===== v8.5.0 speed +30%: spins 5 -> 6.5 =====
    const spins = 6.5, TWO = Math.PI*2;
    const extra = spins*TWO*dir;

    // final absolute angle
    return (-safeCenter) + extra;
  }

  function spinTo(items, targetAngle, durationMs){
    return new Promise(resolve=>{
      isSpinning = true;
      playDrum();

      const startAngle = wheelAngle;
      const delta = targetAngle - startAngle;

      const t0 = performance.now();

      const tick = (t)=>{
        let p = (t - t0) / durationMs;
        if(p > 1) p = 1;

        const e = easeOutCubic(p);
        wheelAngle = startAngle + delta * e;

        renderAtAngle(items, wheelAngle);

        if(p < 1){
          requestAnimationFrame(tick);
        }else{
          // final settle (no snap redraw different angle; keep same wheelAngle)
          isSpinning = false;
          resolve();
        }
      };
      requestAnimationFrame(tick);
    });
  }

  function getRemainingNames(){
    return nameList.filter(n=>!usedNames.includes(n));
  }

  function pickRandom(arr){
    return arr[Math.floor(Math.random()*arr.length)];
  }

  function saveLog(mode, nameOrCat, verseId){
    ensureLogsInit();
    const logs = JSON.parse(localStorage.getItem(K_LOGS) || "[]");
    const ref = (window.VERSE_REF_MAP && window.VERSE_REF_MAP[verseId]) ? window.VERSE_REF_MAP[verseId] : "";
    logs.push({
      time: nowTS(),
      mode,
      who: nameOrCat,
      verse: verseId,
      ref
    });
    localStorage.setItem(K_LOGS, JSON.stringify(logs));
  }

  function markNameUsed(n){
    if(!usedNames.includes(n)){
      usedNames.push(n);
      localStorage.setItem(K_USEDN, JSON.stringify(usedNames));
    }
  }
  function markVerseUsed(v){
    if(!usedVerses.includes(v)){
      usedVerses.push(v);
      localStorage.setItem(K_USEDV, JSON.stringify(usedVerses));
    }
  }

  function allNamesDone(){
    return nameList.length>0 && usedNames.length >= nameList.length;
  }

  function updateButtons(){
    // base
    lockBtn.disabled = isSpinning;
    resetBtn.disabled = isSpinning;
    pdfBtn.disabled = isSpinning;

    if(!locked){
      startBtn.disabled = true;
      secondBtn.style.display = "none";
      viewerBtn.style.display = "none";
      return;
    }

    // locked
    if(stage === 0){
      startBtn.disabled = isSpinning || allNamesDone();
      secondBtn.style.display = "none";
      viewerBtn.style.display = "none";
    }else if(stage === 1){
      startBtn.disabled = true;
      secondBtn.style.display = "inline-block";
      viewerBtn.style.display = "none";
    }else if(stage === 2){
      startBtn.disabled = true;
      secondBtn.style.display = "none";
      viewerBtn.style.display = "inline-block";
    }
  }

  function setPdfBlink(on){
    if(on){
      pdfBtn.classList.add("blinking");
    }else{
      pdfBtn.classList.remove("blinking");
    }
  }

  function showFinishMessage(){
    const done = usedNames.length;
    setStatus(
`ğŸ‰ æ­¤è¼ªè½‰ç›¤å·²å®Œæˆ ${done} ä½çš„ç´…åŒ…æŠ½ç±¤
ğŸ“„ è«‹æŒ‰ã€ŒæŠ½ç±¤ç´€éŒ„ PDFã€ä¸‹è¼‰ç´€éŒ„ï¼Œæˆ–
ğŸ” è¼¸å…¥æ–°å§“å â†’ æŒ‰ã€Œé–å®šåå–®ã€é–‹å§‹ä¸‹ä¸€è¼ªï¼›ä¹Ÿå¯æŒ‰ã€Œå…¨éƒ¨æ­¸é›¶ã€`
    );
    setPdfBlink(true);
  }

  // =============================
  // init load
  // =============================
  (function init(){
    ensureLogsInit();

    try{
      const savedList = localStorage.getItem(K_LIST);
      if(savedList){
        nameList = JSON.parse(savedList) || [];
        if(nameList.length){
          locked = true;
          nameInput.value = nameList.join(" ");
          setStatus(`åå–®å·²è¼‰å…¥ï¼Œå…± ${nameList.length} ä½`);
          renderAtAngle(nameList, wheelAngle);
        }
      }
      usedNames = JSON.parse(localStorage.getItem(K_USEDN) || "[]");
      usedVerses= JSON.parse(localStorage.getItem(K_USEDV) || "[]");

      const fin = localStorage.getItem(K_FIN) === "1";
      if(fin && locked){
        showFinishMessage();
      }
    }catch(e){
      // ignore
    }

    updateButtons();
  })();

  // =============================
  // handlers
  // =============================
  lockBtn.addEventListener("click", ()=>{
    if(isSpinning) return;

    const raw = (nameInput.value || "").trim();
    if(!raw){
      alert("è«‹è¼¸å…¥å§“åï¼");
      return;
    }
    const arr = parseNames(raw);

    if(arr.length < 2){
      alert("è‡³å°‘è¦æœ‰å…©ä½æ‰å¯ä»¥ï¼");
      return;
    }
    if(hasDup(arr)){
      alert("Oops, æœ‰å§“åé‡è¤‡è¼¸å…¥äº†å”·ï¼");
      return;
    }

    // NOTE: é–‹å§‹ä¸‹ä¸€è¼ªï¼šåªé‡ç½® usedNames / stageï¼Œä¸æ¸…ç©º logs / usedVerses
    nameList = arr;
    locked = true;
    stage = 0;
    selectedName = null;
    selectedVerse = null;
    hideCenter();

    usedNames = [];
    localStorage.setItem(K_USEDN, "[]");
    localStorage.setItem(K_LIST, JSON.stringify(nameList));
    localStorage.setItem(K_FIN, "0");

    // keep wheelAngle as-is (avoid visual jump); just redraw at current angle
    renderAtAngle(nameList, wheelAngle);

    setPdfBlink(false);
    setStatus(`åå–®å·²é–å®šï¼Œå…± ${nameList.length} ä½`);
    updateButtons();
  });

  resetBtn.addEventListener("click", ()=>{
    if(isSpinning) return;
    localStorage.clear();
    alert("æ‰€æœ‰è³‡æ–™å·²æ¸…ç©ºï¼");
    location.reload();
  });

  startBtn.addEventListener("click", async ()=>{
    if(isSpinning) return;
    if(!locked){
      alert("è«‹å…ˆé–å®šåå–®ï¼");
      return;
    }
    if(allNamesDone()){
      showFinishMessage();
      updateButtons();
      return;
    }

    const remaining = getRemainingNames();
    if(remaining.length === 0){
      showFinishMessage();
      updateButtons();
      return;
    }

    // pick winner name
    selectedName = pickRandom(remaining);
    selectedVerse = null;

    // compute index and target angle (round1: CCW => clockwise=false)
    const idx = nameList.indexOf(selectedName);
    const target = computeTargetAngle(nameList.length, idx, /*clockwise*/ false);

    stage = 0;
    hideCenter();
    setStatus("ğŸ¯ ç¬¬ 1 è¼ªï¼šå§“åè¼ªç›¤æŠ½ç±¤ä¸­â€¦");
    updateButtons();

    // duration: keep as configured in v8.4.1 (do not change logic)
    const DURATION_MS = 5200;

    await spinTo(nameList, target, DURATION_MS);

    setStatus(`ğŸ¯ ç¬¬ 1 è¼ªå®Œæˆï¼šæŠ½ä¸­ã€Œ${selectedName}ã€`);
    stage = 1;

    // show second button quickly (no extra delays)
    secondBtn.style.display = "inline-block";
    secondBtn.classList.add("blinking");

    updateButtons();
  });

  secondBtn.addEventListener("click", async ()=>{
    if(isSpinning) return;

    secondBtn.classList.remove("blinking");
    secondBtn.style.display = "none";

    if(!selectedName){
      alert("è«‹å…ˆå®Œæˆç¬¬ä¸€è¼ªï¼");
      stage = 0;
      updateButtons();
      return;
    }

    // pick verse (unique)
    const verseNums = window.VERSE_REF_MAP ? Object.keys(window.VERSE_REF_MAP) : [];
    const avail = verseNums.filter(v=>!usedVerses.includes(v));
    if(avail.length === 0){
      alert("128 å€‹ç¶“å¥éƒ½å·²æŠ½å®Œï¼");
      stage = 0;
      updateButtons();
      return;
    }

    selectedVerse = pickRandom(avail);
    markVerseUsed(selectedVerse);

    // Round2: still show SAME name wheel; must stop at same person (clockwise)
    const idx = nameList.indexOf(selectedName);
    const target = computeTargetAngle(nameList.length, idx, /*clockwise*/ true);

    hideCenter();
    setStatus("ğŸ ç¬¬ 2 è¼ªï¼šç¥ç¦ç¶“å¥è¼ªç›¤æŠ½ç±¤ä¸­â€¦");
    stage = 1;
    updateButtons();

    const DURATION_MS = 5200;

    await spinTo(nameList, target, DURATION_MS);

    // show book/chapter in center AFTER stop (no â€œcheatâ€ feeling)
    const ref = window.VERSE_REF_MAP ? window.VERSE_REF_MAP[selectedVerse] : "";
    let book = "", chap = "";
    if(ref){
      const parts = ref.split(/\s+/);
      book = parts[0] || ref;
      chap = parts.slice(1).join(" ") || "";
    }
    showCenter(book, chap);

    setStatus(`ğŸ ç¬¬ 2 è¼ªå®Œæˆï¼šæŠ½ä¸­ç¶“å¥ã€Œ${selectedVerse}ã€`);

    // log + mark name used (end of one person)
    saveLog("å§“åæ¨¡å¼", selectedName, selectedVerse);
    markNameUsed(selectedName);

    // store lastResult for viewer
    localStorage.setItem(K_LAST, JSON.stringify({
      name: selectedName,
      verse: selectedVerse
    }));

    stage = 2;
    updateButtons();
  });

  viewerBtn.addEventListener("click", ()=>{
    if(!selectedName || !selectedVerse) return;

    // allow next person after returning from viewer
    // viewer æœƒä»¥ querystring å¸¶å› next=1
    const ref = window.VERSE_REF_MAP ? (window.VERSE_REF_MAP[selectedVerse] || "") : "";
    const qs =
      `viewer.html?name=${encodeURIComponent(selectedName)}`+
      `&verse=${encodeURIComponent(selectedVerse)}`+
      `&ref=${encodeURIComponent(ref)}`;

    window.location.href = qs;
  });

  // On return from viewer (next=1), keep list & allow start next person
  (function handleReturn(){
    const url = new URL(location.href);
    const next = url.searchParams.get("next");
    if(next === "1"){
      // reset stage for next person
      selectedName = null;
      selectedVerse = null;
      stage = 0;
      hideCenter();

      // if finished, show finish message
      if(allNamesDone()){
        localStorage.setItem(K_FIN, "1");
        showFinishMessage();
      }else{
        setStatus(`åå–®å·²é–å®šï¼Œå…± ${nameList.length} ä½\nå·²å®Œæˆï¼š${usedNames.length}/${nameList.length}`);
      }

      updateButtons();

      // clean param without reloading
      url.searchParams.delete("next");
      history.replaceState({}, "", url.toString());
    }
  })();

  // PDF export (Canvas -> image -> PDF)
  pdfBtn.addEventListener("click", async ()=>{
    try{
      ensureLogsInit();
      const logs = JSON.parse(localStorage.getItem(K_LOGS) || "[]");
      if(!logs.length){
        alert("å°šç„¡ç´€éŒ„");
        return;
      }

      // create printable canvas
      const lineH = 34;
      const pad = 30;
      const w = 1200;

      const header = "BlessingCards128 æŠ½ç±¤ç´€éŒ„";
      const lines = logs.map(l=>{
        const ref = l.ref ? `ï¼ˆ${l.ref}ï¼‰` : "";
        return `[${l.time}] ${l.who}ï½œæŠ½ä¸­çš„ç¶“å¥ç´…åŒ…; ç·¨è™Ÿã€Œ${l.verse}ã€${ref}`;
      });

      const h = pad*2 + 60 + lines.length*lineH;

      const c = document.createElement("canvas");
      c.width = w;
      c.height = h;
      const g = c.getContext("2d");

      // background
      g.fillStyle = "#ffffff";
      g.fillRect(0,0,w,h);

      // header
      g.fillStyle = "#5b3a00";
      g.font = "bold 34px Noto Sans TC, system-ui, Arial";
      g.fillText(header, pad, pad+36);

      // lines
      g.font = "28px Noto Sans TC, system-ui, Arial";
      let y = pad + 80;
      for(const ln of lines){
        g.fillText(ln, pad, y);
        y += lineH;
      }

      // Make image
      const imgData = c.toDataURL("image/png");

      // jsPDF from CDN-less: minimal embed (use window.jspdf if present)
      // If not present, load jsPDF dynamically
      const ensureJsPDF = ()=>{
        return new Promise((resolve, reject)=>{
          if(window.jspdf && window.jspdf.jsPDF) return resolve();
          const s = document.createElement("script");
          s.src = "https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js";
          s.onload = ()=> resolve();
          s.onerror = ()=> reject(new Error("jsPDF load failed"));
          document.head.appendChild(s);
        });
      };

      await ensureJsPDF();
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({ unit:"pt", format:"a4" });

      // fit image into A4
      const pageW = doc.internal.pageSize.getWidth();
      const pageH = doc.internal.pageSize.getHeight();

      // Convert px to pt roughly (assume 96dpi)
      const imgWpt = w * 0.75;
      const imgHpt = h * 0.75;

      let scale = Math.min((pageW-40)/imgWpt, (pageH-40)/imgHpt);
      if(scale > 1) scale = 1;

      const drawW = imgWpt * scale;
      const drawH = imgHpt * scale;

      doc.addImage(imgData, "PNG", 20, 20, drawW, drawH);

      doc.save("BlessingCards128_æŠ½ç±¤ç´€éŒ„.pdf");

      // after download, stop blinking
      setPdfBlink(false);

    }catch(err){
      console.error(err);
      alert("PDF ç”¢ç”Ÿå¤±æ•—ï¼šè«‹æŸ¥çœ‹ Console éŒ¯èª¤è¨Šæ¯ã€‚");
    }
  });
  </script>
</body>
</html>
