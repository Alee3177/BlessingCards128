<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<title>BlessingCards128｜祝福經句紅包（v5.1）</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<style>
body {
  background: #fff8e7;
  font-family: "Noto Sans TC", system-ui, -apple-system, BlinkMacSystemFont,
    "Segoe UI", sans-serif;
  text-align: center;
  padding: 22px;
  color: #5b3a00;
}

h1 {
  color: #b07500;
  font-size: 26px;
  margin-bottom: 10px;
}

/* LOGO */
.logo {
  width: 120px;
  margin-bottom: 14px;
}

/* 輸入框 */
#nameInput {
  width: 280px;
  padding: 10px;
  font-size: 18px;
  border-radius: 8px;
  border: 1px solid #bf8a3e;
  margin-bottom: 12px;
}

/* 共用按鈕 */
.btn {
  background: #f7c76c;
  border: none;
  padding: 12px 22px;
  border-radius: 25px;
  font-size: 18px;
  color: #5b3a00;
  cursor: pointer;
  margin: 6px;
}
.btn:hover {
  background: #f3b84f;
}
.btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
}

/* 第二輪按鈕閃爍 */
@keyframes blink {
  0% {
    opacity: 1;
  }
  50% {
    opacity: 0.28;
  }
  100% {
    opacity: 1;
  }
}
.blinking {
  animation: blink 0.9s infinite;
}

/* 轉盤容器 */
#wheelContainer {
  position: relative;
  width: 380px;
  height: 380px;
  margin: 22px auto;
}

/* Canvas */
#wheelCanvas {
  width: 380px;
  height: 380px;
}

/* 指針 ▼ */
#wheelPointer {
  position: absolute;
  top: -26px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 44px;
  color: red;
  z-index: 20;
}

/* 第二輪經句編號 Badge（指針下方） */
#verseBadge {
  position: absolute;
  top: 4px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 20px;
  font-weight: bold;
  color: #5b3a00;
  background: rgba(255, 255, 255, 0.8);
  padding: 4px 10px;
  border-radius: 16px;
  border: 1px solid #e0b46a;
  display: none;
  z-index: 19;
}

/* 狀態訊息 */
#statusText {
  font-size: 20px;
  margin-top: 8px;
  color: #a56b00;
}
#statusText.error {
  color: #c0392b;
  font-weight: bold;
}
</style>
</head>

<body>
<h1>祝福經句紅包（BlessingCards128）</h1>
<img src="logo3524.png" class="logo" alt="logo" />

<!-- 姓名輸入 -->
<input
  id="nameInput"
  placeholder="輸入所有姓名，用「、」或空白分隔"
/><br />

<button class="btn" onclick="lockList()">鎖定名單</button>
<button id="startBtn" class="btn" onclick="startFirstRound()">
  開始抽姓名 + 經句
</button>
<button class="btn" onclick="resetAll()">全部歸零</button>
<button class="btn" onclick="exportPDF()">抽籤紀錄 PDF</button>

<!-- 第二輪按鈕 -->
<button
  id="secondBtn"
  class="btn"
  style="display: none"
  onclick="startSecondRound()"
>
  抽紅包（第二輪）
</button>

<!-- 看紅包內容 -->
<button
  id="viewerBtn"
  class="btn"
  style="display: none"
  onclick="gotoViewer()"
>
  看紅包內容
</button>

<!-- 轉盤 -->
<div id="wheelContainer">
  <div id="wheelPointer">▼</div>
  <div id="verseBadge"></div>
  <canvas id="wheelCanvas" width="380" height="380"></canvas>
</div>

<div id="statusText">請輸入姓名並鎖定名單</div>

<!-- 經句編號 → 書卷章節 對照 -->
<script src="verseRefMap.js"></script>
<!-- jsPDF -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script>
/* ------------------------------------
   全域變數
-------------------------------------*/

const LS_PREFIX = "BC128_";

let nameList = []; // 鎖定後的姓名順序
let locked = false;

let selectedName = null; // 第一輪抽中的姓名
let selectedVerse = null; // 第二輪抽中的經句編號（字串 "001"...）

let usedNames = []; // 已完成兩輪的人
let usedVerses = []; // 已抽過的經文編號
let roundFinished = false;

const canvas = document.getElementById("wheelCanvas");
const ctx = canvas.getContext("2d");
const CENTER = 190;
const RADIUS = 180;

const startBtn = document.getElementById("startBtn");
const secondBtn = document.getElementById("secondBtn");
const viewerBtn = document.getElementById("viewerBtn");
const statusText = document.getElementById("statusText");
const verseBadge = document.getElementById("verseBadge");

/* ------------------------------------
   工具：LocalStorage 快捷
-------------------------------------*/
function lsGet(key, def) {
  const v = localStorage.getItem(LS_PREFIX + key);
  if (v === null || v === undefined) return def;
  try {
    return JSON.parse(v);
  } catch {
    return def;
  }
}
function lsSet(key, value) {
  localStorage.setItem(LS_PREFIX + key, JSON.stringify(value));
}

/* ------------------------------------
   Drum 音效
-------------------------------------*/
function playDrum() {
  const a = new Audio("audio/drum.mp3");
  a.play().catch(() => {});
}

/* ------------------------------------
   初始化：從 localStorage 載入狀態
-------------------------------------*/
(function init() {
  const savedNames = lsGet("nameList", null);
  if (savedNames && Array.isArray(savedNames) && savedNames.length >= 2) {
    nameList = savedNames;
    locked = true;
    document.getElementById("nameInput").value = nameList.join("、");
    statusText.innerText = `名單已載入，共 ${nameList.length} 位`;
    drawWheel(nameList); // 畫出靜止輪盤
  }

  usedNames = lsGet("usedNames", []);
  usedVerses = lsGet("usedVerses", []);
  roundFinished = lsGet("roundFinished", false);

  if (roundFinished && nameList.length > 0) {
    statusText.textContent = "⚠ 本輪已完成全部抽籤，請按「全部歸零」。";
    startBtn.disabled = true;
  }
})();

/* ------------------------------------
   鎖定名單
-------------------------------------*/
function lockList() {
  const raw = document.getElementById("nameInput").value.trim();
  if (!raw) {
    alert("請先輸入姓名！");
    return;
  }

  const arr = raw
    .split(/[,、\s]+/)
    .map((s) => s.trim())
    .filter((s) => s.length > 0);

  if (arr.length < 2) {
    alert("至少要兩位姓名才能轉輪盤！");
    return;
  }

  nameList = arr;
  locked = true;
  usedNames = [];
  usedVerses = [];
  roundFinished = false;
  selectedName = null;
  selectedVerse = null;

  lsSet("nameList", nameList);
  lsSet("usedNames", []);
  lsSet("usedVerses", []);
  lsSet("roundFinished", false);

  statusText.textContent = `名單已鎖定，共 ${nameList.length} 位`;
  startBtn.disabled = false;
  secondBtn.style.display = "none";
  viewerBtn.style.display = "none";
  verseBadge.style.display = "none";

  drawWheel(nameList);
}

/* ------------------------------------
   畫輪盤（靜態，從 -90° 開始）
-------------------------------------*/
function drawWheel(items, options = {}) {
  const { hideText = false, highlightIndex = null, highlightText = "" } =
    options;

  ctx.clearRect(0, 0, 380, 380);
  if (!items || items.length === 0) return;

  const count = items.length;
  const arc = (Math.PI * 2) / count;

  for (let i = 0; i < count; i++) {
    const start = arc * i - Math.PI / 2;
    const end = start + arc;

    // 底色
    ctx.beginPath();
    ctx.moveTo(CENTER, CENTER);
    ctx.arc(CENTER, CENTER, RADIUS, start, end);
    ctx.closePath();
    ctx.fillStyle = i % 2 === 0 ? "#fde7b5" : "#fcdca0";
    ctx.fill();

    // 分隔線
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 2;
    ctx.stroke();

    // 文字 / 或空白
    if (!hideText) {
      ctx.save();
      ctx.translate(CENTER, CENTER);
      const mid = start + arc / 2;
      ctx.rotate(mid);
      ctx.textAlign = "right";
      ctx.font = "22px Noto Sans TC";
      ctx.fillStyle = "#5b3a00";
      ctx.fillText(items[i], RADIUS - 22, 10);
      ctx.restore();
    }
  }

  // 若有 highlightIndex 與 highlightText：在該扇區內寫上文字
  if (highlightIndex != null && highlightText) {
    const mid = arc * highlightIndex - Math.PI / 2 + arc / 2;
    ctx.save();
    ctx.translate(CENTER, CENTER);
    ctx.rotate(mid);
    ctx.textAlign = "right";
    ctx.font = "24px Noto Sans TC";
    ctx.fillStyle = "#b03a00";
    ctx.fillText(highlightText, RADIUS - 40, 10);
    ctx.restore();
  }
}

/* ------------------------------------
   動畫 easing
-------------------------------------*/
function easeOutCubic(t) {
  return 1 - Math.pow(1 - t, 3);
}

/* ------------------------------------
   核心：精準指針的轉盤動畫
   items      : 顯示用陣列（第一輪 = 姓名，第二輪 = 一樣的姓名或空白）
   clockwise  : true 順時針 / false 逆時針
   forcedIndex: 目標 index（必須命中）
   options    : { hideText, onEnd } 第二輪可隱藏文字
-------------------------------------*/
function spinWheel(items, clockwise, forcedIndex, options = {}) {
  const { hideText = false } = options;

  return new Promise((resolve) => {
    playDrum();
    verseBadge.style.display = "none";

    const count = items.length;
    const arc = (Math.PI * 2) / count;

    // 要命中的扇區 index
    const k = forcedIndex;

    // 若沒有 forcedIndex，就隨機一個，但依然套用精準角度
    const targetIndex =
      typeof k === "number" && k >= 0 && k < count
        ? k
        : Math.floor(Math.random() * count);

    // 讓「目標扇區中心」對準指針：
    // drawWheel 時，扇區中心角度 = (-π/2 + (i+0.5)*arc) + angle
    // 令其等於指針角度 -π/2 → 解得 angleBase = -(i+0.5)*arc
    const baseAngle = -(targetIndex + 0.5) * arc;

    const direction = clockwise ? 1 : -1;
    const spins = 4 + Math.random() * 2; // 4~6 圈
    const finalAngle = baseAngle + direction * spins * 2 * Math.PI;

    const duration = 5000;
    const startTime = performance.now();

    function frame(now) {
      let t = (now - startTime) / duration;
      if (t > 1) t = 1;
      const eased = easeOutCubic(t);
      const angle = finalAngle * eased;

      ctx.save();
      ctx.clearRect(0, 0, 380, 380);
      ctx.translate(CENTER, CENTER);
      ctx.rotate(angle);
      ctx.translate(-CENTER, -CENTER);
      drawWheel(items, { hideText });
      ctx.restore();

      if (t < 1) {
        requestAnimationFrame(frame);
      } else {
        // 最後再 snap 一次，消除浮點殘差，讓指針 100% 命中中心
        ctx.save();
        ctx.clearRect(0, 0, 380, 380);
        ctx.translate(CENTER, CENTER);
        ctx.rotate(finalAngle);
        ctx.translate(-CENTER, -CENTER);
        drawWheel(items, { hideText });
        ctx.restore();

        resolve(targetIndex);
      }
    }

    requestAnimationFrame(frame);
  });
}

/* ------------------------------------
   第一輪：抽姓名（逆時針）
-------------------------------------*/
async function startFirstRound() {
  if (roundFinished) {
    alert("本輪已完成全部抽籤，請按「全部歸零」。");
    return;
  }
  if (!locked || nameList.length < 2) {
    alert("請先輸入姓名並鎖定名單！");
    return;
  }

  // 剩餘未抽過的人
  const remaining = nameList.filter((n) => !usedNames.includes(n));
  if (remaining.length === 0) {
    alert("全部姓名都已完成紅包抽籤！");
    roundFinished = true;
    lsSet("roundFinished", true);
    startBtn.disabled = true;
    return;
  }

  // 在剩餘名單中隨機選一位 winner
  const winner =
    remaining[Math.floor(Math.random() * remaining.length)];
  const forcedIndex = nameList.indexOf(winner);

  selectedName = null;
  selectedVerse = null;
  viewerBtn.style.display = "none";
  secondBtn.style.display = "none";
  verseBadge.style.display = "none";

  statusText.textContent = "第 1 輪：姓名輪盤抽籤中…";

  // 以「姓名清單」為顯示內容，逆時針轉，精準落在 winner
  await spinWheel(nameList, false, forcedIndex);

  selectedName = winner;
  lsSet("currentName", winner);

  statusText.textContent = `第 1 輪完成：抽中「${winner}」`;

  // 顯示第二輪按鈕（閃爍）
  setTimeout(() => {
    secondBtn.style.display = "inline-block";
    secondBtn.classList.add("blinking");
  }, 800);
}

/* ------------------------------------
   第二輪：抽經句（順時針）
   外觀：沿用姓名輪盤，但不顯示文字（扇區空白）
   內部：從 001–128 未抽過經文中抽一個
   結束時：指針仍停在第一輪中獎者位置，
           verseBadge 顯示編號，
           status 顯示第 2 輪完成訊息。
-------------------------------------*/
async function startSecondRound() {
  secondBtn.classList.remove("blinking");
  secondBtn.style.display = "none";

  if (!selectedName) {
    alert("請先完成第一輪抽姓名！");
    return;
  }

  // 取得所有經句編號
  const verseNums = Object.keys(window.VERSE_REF_MAP || {});
  if (!verseNums.length) {
    alert("找不到經句對照表（VERSE_REF_MAP）！");
    return;
  }

  // 過濾未抽過的
  const available = verseNums.filter((v) => !usedVerses.includes(v));
  if (!available.length) {
    alert("128 篇經句都已經抽完了！");
    return;
  }

  statusText.textContent = "第 2 輪：祝福經句輪盤抽籤中…";

  // 讓畫面看起來仍是「姓名輪盤」，但扇區不顯示文字
  const forcedIndex = nameList.indexOf(selectedName);
  await spinWheel(nameList, true, forcedIndex, { hideText: true });

  // 內部真正抽出一個經句編號（不重複）
  selectedVerse =
    available[Math.floor(Math.random() * available.length)];
  usedVerses.push(selectedVerse);
  lsSet("usedVerses", usedVerses);
  lsSet("currentVerse", selectedVerse);

  const ref = (window.VERSE_REF_MAP || {})[selectedVerse] || "";
  statusText.textContent = `第 2 輪完成：抽中經句「${selectedVerse}」`;

  // 在指針下方顯示經句編號
  verseBadge.textContent = `編號「${selectedVerse}」`;
  verseBadge.style.display = "block";

  // 記錄 log + 標記此人已抽過
  saveRecord(selectedName, selectedVerse);

  // 顯示「看紅包內容」按鈕
  setTimeout(() => {
    viewerBtn.style.display = "inline-block";
  }, 800);
}

/* ------------------------------------
   儲存抽籤紀錄
-------------------------------------*/
function saveRecord(name, verse) {
  const now = new Date();
  const ts =
    `${now.getFullYear()}/` +
    `${String(now.getMonth() + 1).padStart(2, "0")}/` +
    `${String(now.getDate()).padStart(2, "0")} ` +
    `${String(now.getHours()).padStart(2, "0")}:` +
    `${String(now.getMinutes()).padStart(2, "0")}:` +
    `${String(now.getSeconds()).padStart(2, "0")}`;

  const ref = (window.VERSE_REF_MAP || {})[verse] || "";

  let logs = lsGet("drawLogs", []);
  logs.push({
    time: ts,
    mode: "姓名模式",
    name,
    verse,
    ref,
  });
  lsSet("drawLogs", logs);

  if (!usedNames.includes(name)) {
    usedNames.push(name);
    lsSet("usedNames", usedNames);
  }

  if (usedNames.length >= nameList.length) {
    roundFinished = true;
    lsSet("roundFinished", true);
    startBtn.disabled = true;
    // 這裡只做狀態更新，不立刻 alert，
    // 讓使用者在看完紅包/下一位時感受到流程自然。
  }
}

/* ------------------------------------
   前往 viewer.html（帶 name & verse）
-------------------------------------*/
function gotoViewer() {
  if (!selectedName || !selectedVerse) {
    alert("請先完成兩輪抽籤！");
    return;
  }
  const url =
    `viewer.html?name=${encodeURIComponent(selectedName)}` +
    `&verse=${encodeURIComponent(selectedVerse)}`;
  window.location.href = url;
}

/* ------------------------------------
   全部歸零
-------------------------------------*/
function resetAll() {
  if (!confirm("確定要清除目前這一輪的所有資料嗎？")) return;
  Object.keys(localStorage)
    .filter((k) => k.startsWith(LS_PREFIX))
    .forEach((k) => localStorage.removeItem(k));
  alert("所有資料已清空！");
  location.reload();
}

/* ------------------------------------
   PDF 匯出：使用思源黑體（外部字型）
-------------------------------------*/
async function exportPDF() {
  let logs = lsGet("drawLogs", []);
  if (!logs.length) {
    alert("目前尚無抽籤紀錄！");
    return;
  }

  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({ unit: "pt", format: "a4" });

  // 載入外部字型（思源黑體）
  let fontData;
  try {
    const res = await fetch("fonts/SourceHanSansTC-Regular.ttf");
    const buf = await res.arrayBuffer();
    const bytes = new Uint8Array(buf);
    let binary = "";
    for (let i = 0; i < bytes.length; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    fontData = btoa(binary);
  } catch (e) {
    console.error(e);
    alert(
      "無法載入字型 fonts/SourceHanSansTC-Regular.ttf，請確認檔案存在。"
    );
    return;
  }

  doc.addFileToVFS("SourceHanSansTC-Regular.ttf", fontData);
  doc.addFont("SourceHanSansTC-Regular.ttf", "SourceHanTC", "normal");
  doc.setFont("SourceHanTC", "normal");

  doc.setFontSize(18);
  doc.text("BlessingCards128 抽籤紀錄", 40, 40);

  let y = 70;
  doc.setFontSize(13);

  logs.forEach((log) => {
    const line = `[${log.time}] ${log.name}｜${log.mode} 抽中經句：${
      log.verse
    }${log.ref ? "（" + log.ref + "）" : ""}`;
    doc.text(line, 40, y);
    y += 22;
    if (y > 780) {
      doc.addPage();
      y = 60;
    }
  });

  doc.save("BlessingCards128_抽籤紀錄.pdf");
}
</script>
</body>
</html>
