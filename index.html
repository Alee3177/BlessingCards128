<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>BlessingCards128｜祝福經句紅包（應許等您拿）</title>

<!-- 讓 logo 優先載入（改善出現很慢） -->
<link rel="preload" as="image" href="logo3524.png">

<style>
  :root{--bg:#fff8e7;--text:#5b3a00;--accent:#b07500;--btn:#f7c76c;--btn2:#f3b84f;}
  body{background:var(--bg);font-family:"Noto Sans TC",system-ui,-apple-system,"Segoe UI",Arial,sans-serif;text-align:center;padding:22px;color:var(--text)}
  h1{color:var(--accent);font-size:26px;margin:0 0 10px}
  .logo{width:120px;margin:10px 0 12px}
  #nameInput{width:320px;max-width:90vw;padding:10px 12px;font-size:18px;border-radius:10px;border:1px solid #bf8a3e;margin:10px 0}
  .btn{background:var(--btn);border:none;padding:12px 18px;border-radius:999px;font-size:18px;color:var(--text);cursor:pointer;margin:6px;box-shadow:0 1px 0 rgba(0,0,0,.08)}
  .btn:hover{background:var(--btn2)}
  .btn:disabled{opacity:.45;cursor:not-allowed}
  @keyframes blink{0%{opacity:1}50%{opacity:.25}100%{opacity:1}}
  .blinking{animation:blink 1s infinite}

  #wheelContainer{position:relative;width:380px;height:380px;margin:18px auto 10px}
  #wheelCanvas{width:380px;height:380px}
  /* 指針 ▼：固定上方、朝下、尖端貼齊外緣 */
  #wheelPointer{
    position:absolute;
    top:-30px;
    left:50%;
    transform:translateX(-50%);
    font-size:46px;
    color:#d60000;
    line-height:1;
    z-index:20;
    user-select:none;
    pointer-events:none;
  }

  #statusText{font-size:18px;margin-top:10px;color:#a56b00;min-height:24px}
  #statusText.error{color:#c0392b;font-weight:700}

  /* 轉盤中央顯示（第二輪停下來才顯示） */
  #centerRef{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);text-align:center;display:none;z-index:10}
  #centerRef .book{font-size:20px;font-weight:700;color:#5b3a00;white-space:nowrap}
  #centerRef .chap{font-size:18px;color:#5b3a00;white-space:nowrap;margin-top:4px}
</style>
</head>

<body>
  <h1>祝福經句紅包（應許等您拿）</h1>
  <img src="logo3524.png" class="logo" alt="logo">

  <div>
    <input id="nameInput" placeholder="請輸入姓名（可用空白、逗號、頓號分隔）" autocomplete="off" />
    <div>
      <button id="lockBtn" class="btn">鎖定名單</button>
      <button id="startBtn" class="btn" disabled>開始抽姓名 + 經句</button>
      <button id="resetBtn" class="btn">全部歸零</button>
      <button id="pdfBtn" class="btn">抽籤紀錄 PDF</button>
    </div>
    <div>
      <button id="secondBtn" class="btn" style="display:none" disabled>抽紅包（第二輪）</button>
      <button id="viewerBtn" class="btn" style="display:none" disabled>看紅包內容</button>
    </div>
  </div>

  <div id="wheelContainer">
    <div id="wheelPointer">▼</div>
    <canvas id="wheelCanvas" width="380" height="380"></canvas>
    <div id="centerRef">
      <div class="book"></div>
      <div class="chap"></div>
    </div>
  </div>

  <div id="statusText">請輸入姓名並鎖定名單</div>

  <script src="verseRefMap.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <script>
  (() => {
    // ------------------------------
    // Utilities
    // ------------------------------
    const $ = (id) => document.getElementById(id);
    const nameInput = $('nameInput');
    const lockBtn = $('lockBtn');
    const startBtn = $('startBtn');
    const resetBtn = $('resetBtn');
    const pdfBtn = $('pdfBtn');
    const secondBtn = $('secondBtn');
    const viewerBtn = $('viewerBtn');
    const statusText = $('statusText');
    const centerRef = $('centerRef');
    const centerBook = centerRef.querySelector('.book');
    const centerChap = centerRef.querySelector('.chap');

    const canvas = $('wheelCanvas');
    const ctx = canvas.getContext('2d');
    const W = 380, H = 380;
    const CENTER = {x: W/2, y: H/2};
    const RADIUS = 180;

    const STORAGE_KEY = 'BC128_V8';

    const PHASE = {
      IDLE: 'IDLE',
      LOCKED: 'LOCKED',
      R1_SPIN: 'R1_SPIN',
      R1_DONE: 'R1_DONE',
      R2_SPIN: 'R2_SPIN',
      R2_DONE: 'R2_DONE',
      FINISHED: 'FINISHED'
    };

    function nowTS(){
      const d = new Date();
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth()+1).padStart(2,'0');
      const dd = String(d.getDate()).padStart(2,'0');
      const hh = String(d.getHours()).padStart(2,'0');
      const mi = String(d.getMinutes()).padStart(2,'0');
      const ss = String(d.getSeconds()).padStart(2,'0');
      return `${yyyy}/${mm}/${dd} ${hh}:${mi}:${ss}`;
    }

    function safeJsonParse(s, fallback){
      try{ return JSON.parse(s); }catch(_){ return fallback; }
    }

    function normalizeNames(raw){
      const parts = raw
        .trim()
        .split(/[\s,，、]+/)
        .map(s => s.trim())
        .filter(Boolean);
      return parts;
    }

    function hasDuplicates(arr){
      const seen = new Set();
      for(const x of arr){
        const k = String(x);
        if(seen.has(k)) return true;
        seen.add(k);
      }
      return false;
    }

    // ------------------------------
    // Audio (只在點擊/旋轉時播放)
    // ------------------------------
    function playDrum(){
      // 不要在 focus/載入時播放
      try{
        const a = new Audio('audio/drum.mp3');
        a.preload = 'auto';
        a.play().catch(()=>{});
      }catch(_){ }
    }

    // ------------------------------
    // State
    // ------------------------------
    let state = {
      phase: PHASE.IDLE,
      nameList: [],
      usedNames: [],
      usedVerses: [],
      logs: [],
      selectedName: null,
      selectedVerse: null,
      selectedRef: null,
      // 轉盤核心：單一真相
      rotation: 0,            // 目前輪盤旋轉角（弧度）
      lastWinnerIndex: null,  // 第一輪抽中者 index
      spinDurationMs: 2800,   // 加快 30%（相較 4s 量級）
    };

    function loadState(){
      const saved = safeJsonParse(localStorage.getItem(STORAGE_KEY) || '{}', {});
      state = {
        ...state,
        ...saved,
      };
      // 防止舊版本污染
      if(!Array.isArray(state.nameList)) state.nameList = [];
      if(!Array.isArray(state.usedNames)) state.usedNames = [];
      if(!Array.isArray(state.usedVerses)) state.usedVerses = [];
      if(!Array.isArray(state.logs)) state.logs = [];
      if(!Object.values(PHASE).includes(state.phase)) state.phase = PHASE.IDLE;
    }

    function saveState(){
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
        phase: state.phase,
        nameList: state.nameList,
        usedNames: state.usedNames,
        usedVerses: state.usedVerses,
        logs: state.logs,
        selectedName: state.selectedName,
        selectedVerse: state.selectedVerse,
        selectedRef: state.selectedRef,
        rotation: state.rotation,
        lastWinnerIndex: state.lastWinnerIndex,
        spinDurationMs: state.spinDurationMs,
      }));
    }

    function clearState(){
      localStorage.removeItem(STORAGE_KEY);
      state = {
        phase: PHASE.IDLE,
        nameList: [],
        usedNames: [],
        usedVerses: [],
        logs: [],
        selectedName: null,
        selectedVerse: null,
        selectedRef: null,
        rotation: 0,
        lastWinnerIndex: null,
        spinDurationMs: 2800,
      };
    }

    // ------------------------------
    // Rendering
    // ------------------------------
    function drawWheel({items, showLabels, rotation, drawSeparators}){
      ctx.clearRect(0,0,W,H);
      if(!items || items.length === 0) return;

      const n = items.length;
      const arc = Math.PI * 2 / n;
      const angle0 = -Math.PI/2; // 指針在上方

      ctx.save();
      ctx.translate(CENTER.x, CENTER.y);
      ctx.rotate(rotation);
      ctx.translate(-CENTER.x, -CENTER.y);

      for(let i=0;i<n;i++){
        const start = angle0 + i*arc;
        const end = start + arc;
        // slice
        ctx.beginPath();
        ctx.moveTo(CENTER.x, CENTER.y);
        ctx.arc(CENTER.x, CENTER.y, RADIUS, start, end);
        ctx.closePath();
        ctx.fillStyle = (i%2===0)? '#fde7b5' : '#fcdca0';
        ctx.fill();

        if(drawSeparators){
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.stroke();
        }

        if(showLabels){
          const mid = start + arc/2;
          ctx.save();
          ctx.translate(CENTER.x, CENTER.y);
          ctx.rotate(mid);
          ctx.textAlign = 'right';
          ctx.font = '22px "Noto Sans TC", sans-serif';
          ctx.fillStyle = '#5b3a00';
          ctx.fillText(items[i], RADIUS - 22, 10);
          ctx.restore();
        }
      }

      ctx.restore();
    }

    function showCenterRef(refStr){
      if(!refStr){
        centerRef.style.display = 'none';
        centerBook.textContent = '';
        centerChap.textContent = '';
        return;
      }
      // refStr example: "詩篇 118:24"
      const parts = String(refStr).split(' ');
      const book = parts[0] || '';
      const chap = parts.slice(1).join(' ') || '';
      centerBook.textContent = book;
      centerChap.textContent = chap;
      centerRef.style.display = 'block';
    }

    // ------------------------------
    // Core spin (index-based, single truth)
    // ------------------------------
    function easeOutCubic(t){ return 1 - Math.pow(1-t, 3); }

    function computeBaseRotationForIndex(n, targetIndex){
      const arc = (Math.PI*2)/n;
      // 讓 target slice 的中心對準指針（上方 angle0）
      // angle0 + (targetIndex+0.5)*arc + rotation = angle0  => rotation = -(targetIndex+0.5)*arc
      return - (targetIndex + 0.5) * arc;
    }

    function normalizeRotation(r){
      const twoPi = Math.PI*2;
      let x = r % twoPi;
      if(x > Math.PI) x -= twoPi;
      if(x < -Math.PI) x += twoPi;
      return x;
    }

    function spinToIndex({items, targetIndex, clockwise, showLabels}){
      return new Promise((resolve) => {
        const n = items.length;
        const base = computeBaseRotationForIndex(n, targetIndex);

        const dir = clockwise ? 1 : -1;
        const spins = 5; // 固定圈數：避免「有時停不下來」
        const twoPi = Math.PI*2;

        // 目標角（含多圈）
        const target = base + dir * spins * twoPi;
        const startRotation = state.rotation;

        // 動畫期間不要顯示中心 ref
        showCenterRef(null);

        const startTime = performance.now();
        const duration = state.spinDurationMs;

        // 音效：確保「按下後立刻播放」，避免不同步
        playDrum();

        function frame(now){
          let t = (now - startTime) / duration;
          if(t > 1) t = 1;
          const eased = easeOutCubic(t);
          const rot = startRotation + (target - startRotation) * eased;

          drawWheel({
            items,
            showLabels,
            rotation: rot,
            drawSeparators: true
          });

          if(t < 1){
            requestAnimationFrame(frame);
          } else {
            // 最後停在 base（與 target 視覺一致，只差整圈），避免任何 "snap" 跳動
            state.rotation = normalizeRotation(base);
            drawWheel({items, showLabels, rotation: state.rotation, drawSeparators: true});
            saveState();
            resolve();
          }
        }
        requestAnimationFrame(frame);
      });
    }

    // ------------------------------
    // UI state machine
    // ------------------------------
    function setStatus(msg, isError=false){
      statusText.textContent = msg;
      statusText.classList.toggle('error', !!isError);
    }

    function updateButtons(){
      // 依 phase 控制，不再靠一堆 if 防呆
      const p = state.phase;

      const hasLocked = (state.nameList && state.nameList.length >= 2);
      lockBtn.disabled = false;
      resetBtn.disabled = false;
      pdfBtn.disabled = false;

      // start
      startBtn.disabled = !(hasLocked && (p===PHASE.LOCKED || p===PHASE.R2_DONE));

      // second
      const canSecond = (p===PHASE.R1_DONE);
      secondBtn.disabled = !canSecond;
      secondBtn.style.display = canSecond ? 'inline-block' : 'none';
      secondBtn.classList.toggle('blinking', canSecond);

      // viewer
      const canViewer = (p===PHASE.R2_DONE);
      viewerBtn.disabled = !canViewer;
      viewerBtn.style.display = canViewer ? 'inline-block' : 'none';

      // input
      // 名單鎖定後仍可看文字，但不強制清空
      // 若你想鎖死輸入，可改為 true
      nameInput.disabled = false;
    }

    function remainingNames(){
      return state.nameList.filter(n => !state.usedNames.includes(n));
    }

    function allNamesFinished(){
      return state.usedNames.length >= state.nameList.length && state.nameList.length >= 2;
    }

    // ------------------------------
    // Actions
    // ------------------------------
    async function onLock(){
      const raw = nameInput.value;
      const list = normalizeNames(raw);

      if(list.length < 2){
        alert('至少要兩位才可以！');
        return;
      }
      if(hasDuplicates(list)){
        alert('Oops, 有姓名被重複輸入了唷！');
        return;
      }

      state.nameList = list;
      state.usedNames = [];
      state.selectedName = null;
      state.selectedVerse = null;
      state.selectedRef = null;
      state.lastWinnerIndex = null;
      state.rotation = 0;
      state.phase = PHASE.LOCKED;

      saveState();

      drawWheel({items: state.nameList, showLabels: true, rotation: state.rotation, drawSeparators:true});
      setStatus(`名單已鎖定，共 ${state.nameList.length} 位`);
      updateButtons();
    }

    async function onStart(){
      if(state.phase !== PHASE.LOCKED && state.phase !== PHASE.R2_DONE){
        return;
      }

      // 若上一位已完成第二輪並看過紅包，下一位可以繼續
      if(allNamesFinished()){
        state.phase = PHASE.FINISHED;
        saveState();
        setStatus(`此輪轉盤已完成 ${state.nameList.length} 位的紅包抽籤，請按「全部歸零」重新開始。`);
        updateButtons();
        return;
      }

      const rem = remainingNames();
      if(rem.length === 0){
        state.phase = PHASE.FINISHED;
        saveState();
        setStatus(`此輪轉盤已完成 ${state.nameList.length} 位的紅包抽籤，請按「全部歸零」重新開始。`);
        updateButtons();
        return;
      }

      // 抽中姓名（邏輯）
      const winner = rem[Math.floor(Math.random()*rem.length)];
      const winnerIndex = state.nameList.indexOf(winner);

      state.phase = PHASE.R1_SPIN;
      state.selectedName = winner;
      state.lastWinnerIndex = winnerIndex;
      state.selectedVerse = null;
      state.selectedRef = null;
      saveState();

      setStatus('第 1 輪：姓名輪盤抽籤中…');
      updateButtons();

      // 視覺：一定轉到 winnerIndex
      await spinToIndex({
        items: state.nameList,
        targetIndex: winnerIndex,
        clockwise: false,
        showLabels: true
      });

      state.phase = PHASE.R1_DONE;
      saveState();

      setStatus(`第 1 輪完成：抽中「${winner}」`);
      updateButtons();
    }

    async function onSecond(){
      if(state.phase !== PHASE.R1_DONE) return;

      // 抽經句（邏輯）
      const keys = Object.keys(window.VERSE_REF_MAP || {}).sort();
      const available = keys.filter(k => !state.usedVerses.includes(k));
      if(available.length === 0){
        setStatus('128 個經句都已抽完！', true);
        return;
      }

      const verse = available[Math.floor(Math.random()*available.length)];
      const ref = (window.VERSE_REF_MAP && window.VERSE_REF_MAP[verse]) ? window.VERSE_REF_MAP[verse] : '';

      state.phase = PHASE.R2_SPIN;
      state.selectedVerse = verse;
      state.selectedRef = ref;
      saveState();

      // 第二輪：外觀沿用 slice 數（姓名數），但不顯示姓名
      setStatus('第 2 輪：祝福經句輪盤抽籤中…');
      updateButtons();

      // 第二輪指針仍停在第一輪抽到的人那一格（同一 index）
      const idx = state.lastWinnerIndex;
      await spinToIndex({
        items: state.nameList,
        targetIndex: idx,
        clockwise: true,
        showLabels: false
      });

      // 停下來後才顯示書卷/章節（避免「像作弊」）
      showCenterRef(ref);

      // 追加紀錄
      const line = {
        time: nowTS(),
        mode: '姓名模式',
        name: state.selectedName,
        verse: verse,
        ref: ref
      };
      state.logs.push(line);

      // 更新已抽名單 / 經句
      if(!state.usedNames.includes(state.selectedName)) state.usedNames.push(state.selectedName);
      if(!state.usedVerses.includes(verse)) state.usedVerses.push(verse);

      state.phase = PHASE.R2_DONE;
      saveState();

      setStatus(`第 2 輪完成：抽中經句「${verse}」`);
      updateButtons();
    }

    function onViewer(){
      if(state.phase !== PHASE.R2_DONE) return;
      // 進 viewer 前，把下一位流程準備好：回來後可直接按「開始抽姓名 + 經句」
      // 我們不在這裡結束本輪；本輪結束只在所有人都抽過後顯示（不跳 alert）
      state.phase = PHASE.R2_DONE; // keep
      saveState();

      const name = encodeURIComponent(state.selectedName || '');
      const verse = encodeURIComponent(state.selectedVerse || '');
      // viewer.html 由你現有版本處理
      window.location.href = `viewer.html?name=${name}&verse=${verse}`;
    }

    function onReset(){
      clearState();
      alert('所有資料已清空！');
      location.reload();
    }

    // ------------------------------
    // PDF export (中文可讀)
    // ------------------------------
    async function exportPDF(){
      try{
        const logs = state.logs || [];
        if(logs.length === 0){
          alert('尚無抽籤紀錄！');
          return;
        }

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({ unit:'pt', format:'a4' });

        // 用 fetch 載入字型（你已確認可放 fonts/SourceHanSansTC-Regular.ttf 或同等）
        // 若你目前 repo 只有 NotoSansTC-Regular.ttf，也可以把下面檔名換成它。
        const fontUrlCandidates = [
          'fonts/SourceHanSansTC-Regular.ttf',
          'fonts/SourceHanSansTC-Regular.otf',
          'fonts/NotoSansTC-Regular.ttf',
          'fonts/NotoSansTC.ttf'
        ];

        let fontDataB64 = null;
        let fontFileName = null;
        for(const url of fontUrlCandidates){
          try{
            const res = await fetch(url, { cache: 'no-store' });
            if(!res.ok) continue;
            const buf = await res.arrayBuffer();
            const bytes = new Uint8Array(buf);
            // Convert to base64 safely
            let binary = '';
            const chunk = 0x8000;
            for(let i=0;i<bytes.length;i+=chunk){
              binary += String.fromCharCode.apply(null, bytes.subarray(i, i+chunk));
            }
            fontDataB64 = btoa(binary);
            fontFileName = url.split('/').pop();
            break;
          }catch(_){ }
        }

        if(!fontDataB64){
          alert('PDF 字型載入失敗：請確認 fonts/ 內有 SourceHanSansTC 或 NotoSansTC 的 ttf/otf。');
          return;
        }

        const vfsName = fontFileName || 'CJK.ttf';
        doc.addFileToVFS(vfsName, fontDataB64);
        doc.addFont(vfsName, 'CJKFont', 'normal');
        doc.setFont('CJKFont', 'normal');

        doc.setFontSize(16);
        doc.text('BlessingCards128 抽籤紀錄', 40, 46);
        doc.setFontSize(12);

        let y = 74;
        const lineH = 18;
        const maxY = 800;

        for(const log of logs){
          const line = `[${log.time}] ${log.name}｜${log.mode}｜抽中經句：${log.verse}（${log.ref || ''}）`;
          const wrapped = doc.splitTextToSize(line, 515);
          for(const part of wrapped){
            doc.text(part, 40, y);
            y += lineH;
            if(y > maxY){
              doc.addPage();
              y = 60;
            }
          }
        }

        doc.save('BlessingCards128_抽籤紀錄.pdf');
      } catch (e){
        console.error(e);
        alert('PDF 產生失敗：請查看 Console 錯誤訊息。');
      }
    }

    // ------------------------------
    // Init + Events
    // ------------------------------
    function init(){
      loadState();

      // restore UI
      if(state.nameList && state.nameList.length >= 2){
        nameInput.value = state.nameList.join('、');
        // 如果回到首頁，仍維持同一份名單，不清空、不重畫成不同狀態
        drawWheel({items: state.nameList, showLabels: true, rotation: state.rotation || 0, drawSeparators:true});
        if(state.phase === PHASE.R2_DONE){
          // 回來時允許下一位：把 phase 切回 LOCKED（但不改輪盤）
          // 你要求「下一位開始時畫面維持一致」：rotation 不變
          if(!allNamesFinished()){
            state.phase = PHASE.LOCKED;
            state.selectedName = null;
            state.selectedVerse = null;
            state.selectedRef = null;
            state.lastWinnerIndex = null;
            showCenterRef(null);
            saveState();
            setStatus('請按「開始抽姓名 + 經句」抽下一位');
          }
        } else if(state.phase === PHASE.FINISHED){
          setStatus(`此輪轉盤已完成 ${state.nameList.length} 位的紅包抽籤，請按「全部歸零」重新開始。`);
        } else {
          setStatus(`名單已載入，共 ${state.nameList.length} 位`);
        }
      } else {
        drawWheel({items: [], showLabels:true, rotation:0, drawSeparators:true});
        setStatus('請輸入姓名並鎖定名單');
      }

      // 按你要求：不要寫出防呆文案在首頁
      // 只用按鈕狀態控制

      updateButtons();

      // Events
      lockBtn.addEventListener('click', onLock);
      startBtn.addEventListener('click', onStart);
      secondBtn.addEventListener('click', onSecond);
      viewerBtn.addEventListener('click', onViewer);
      resetBtn.addEventListener('click', onReset);
      pdfBtn.addEventListener('click', exportPDF);

      // 防止任何 focus/輸入觸發音效：這裡不綁任何自動播放
    }

    init();

  })();
  </script>
</body>
</html>
