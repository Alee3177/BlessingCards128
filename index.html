<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<title>BlessingCards128｜祝福經句紅包（v5.3）</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<style>
body {
    background: #fff8e7;
    font-family: "Noto Sans TC", "Microsoft JhengHei", sans-serif;
    text-align: center;
    padding: 22px;
    color: #5b3a00;
}

h1 {
    color: #b07500;
    font-size: 26px;
    margin-bottom: 10px;
}

.logo {
    width: 120px;
    margin-bottom: 14px;
}

/* 輸入框 */
#nameInput {
    width: 280px;
    padding: 10px;
    font-size: 18px;
    border-radius: 8px;
    border: 1px solid #bf8a3e;
    margin-bottom: 12px;
}

/* 按鈕 */
.btn {
    background: #f7c76c;
    border: none;
    padding: 12px 22px;
    border-radius: 25px;
    font-size: 18px;
    color: #5b3a00;
    cursor: pointer;
    margin: 6px;
}
.btn:hover {
    background: #f3b84f;
}
.btn:disabled {
    opacity: 0.45;
    cursor: not-allowed;
}

/* 第二輪閃爍 */
@keyframes blink {
    0% { opacity: 1; }
    50% { opacity: 0.25; }
    100% { opacity: 1; }
}
.blinking {
    animation: blink 1s infinite;
}

/* 輪盤容器 */
#wheelContainer {
    position: relative;
    width: 380px;
    height: 380px;
    margin: 22px auto;
}

/* canvas */
#wheelCanvas {
    width: 380px;
    height: 380px;
}

/* 指針 ▼（固定在上方朝下） */
#wheelPointer {
    position: absolute;
    top: -26px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 44px;
    color: red;
    z-index: 20;
}

/* 第二輪經句編號 Badge（指針下方） */
#verseBadge {
    position: absolute;
    top: 4px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 20px;
    font-weight: bold;
    color: #5b3a00;
    background: rgba(255,255,255,0.9);
    padding: 4px 10px;
    border-radius: 16px;
    border: 1px solid #e0b46a;
    display: none;
    z-index: 19;
}

/* 狀態訊息 */
#statusText {
    font-size: 20px;
    margin-top: 8px;
    color: #a56b00;
}
#statusText.error {
    color: #c0392b;
    font-weight: bold;
}
</style>
</head>

<body>

<h1>祝福經句紅包（BlessingCards128）</h1>
<img src="logo3524.png" class="logo" />

<!-- 姓名輸入 -->
<input id="nameInput" placeholder="請輸入姓名（用、或空白分隔）" /><br />

<button class="btn" onclick="lockList()">鎖定名單</button>
<button id="startBtn" class="btn" onclick="startFirstRound()">開始抽姓名 + 經句</button>
<button class="btn" onclick="resetAll()">全部歸零</button>
<button class="btn" onclick="exportPDF()">抽籤紀錄 PDF</button>

<button id="secondBtn" class="btn" style="display:none;" onclick="startSecondRound()">抽紅包（第二輪）</button>
<button id="viewerBtn" class="btn" style="display:none;" onclick="gotoViewer()">看紅包內容</button>

<div id="wheelContainer">
    <div id="wheelPointer">▼</div>
    <div id="verseBadge"></div>
    <canvas id="wheelCanvas" width="380" height="380"></canvas>
</div>

<div id="statusText">請輸入姓名並鎖定名單</div>

<script src="verseRefMap.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script>
/* ==================================
   全域變數 & LocalStorage 工具
================================== */
const LS_PREFIX = "BC128_";

let nameList = [];
let locked = false;

let selectedName  = null;   // 第 1 輪抽中的姓名
let selectedVerse = null;   // 第 2 輪抽中的經句編號
let selectedTime  = null;   // 抽籤時間（給 viewer & PNG）

let usedNames   = [];       // 已完成兩輪的人
let usedVerses  = [];       // 已抽過的經句編號
let roundFinished   = false; // 本輪是否已全部抽完
let awaitingSecond  = false; // 是否處在「已完成第 1 輪，等待第 2 輪」

const canvas = document.getElementById("wheelCanvas");
const ctx     = canvas.getContext("2d");
const CENTER  = 190;
const RADIUS  = 180;

// 輪盤目前旋轉角度（radian）
let rotationOffset = 0;

const startBtn   = document.getElementById("startBtn");
const secondBtn  = document.getElementById("secondBtn");
const viewerBtn  = document.getElementById("viewerBtn");
const statusText = document.getElementById("statusText");
const verseBadge = document.getElementById("verseBadge");

function lsGet(key, def){
    const v = localStorage.getItem(LS_PREFIX + key);
    if (v === null || v === undefined) return def;
    try { return JSON.parse(v); } catch { return def; }
}
function lsSet(key, value){
    localStorage.setItem(LS_PREFIX + key, JSON.stringify(value));
}

/* ==================================
   音效
================================== */
function playDrum(){
    const a = new Audio("audio/drum.mp3");
    a.play().catch(()=>{});
}

/* ==================================
   初始化：從 LocalStorage 載入
================================== */
(function init(){
    const savedList = lsGet("nameList", null);
    if (savedList && Array.isArray(savedList) && savedList.length >= 2){
        nameList = savedList;
        locked   = true;
        document.getElementById("nameInput").value = nameList.join("、");
        statusText.textContent = `名單已載入，共 ${nameList.length} 位`;
        drawWheel(nameList);  // 顯示靜態輪盤
    }

    usedNames      = lsGet("usedNames", []);
    usedVerses     = lsGet("usedVerses", []);
    roundFinished  = !!lsGet("roundFinished", false);
    awaitingSecond = !!lsGet("awaitingSecond", false);

    selectedName   = lsGet("currentName", null);
    selectedVerse  = lsGet("currentVerse", null);
    selectedTime   = lsGet("currentTime", null);

    if (roundFinished && nameList.length > 0){
        statusText.textContent = "⚠ 本輪已完成全部抽籤，請按「全部歸零」。";
        startBtn.disabled = true;
    }

    if (awaitingSecond && selectedName && !selectedVerse){
        statusText.textContent = `第 1 輪完成：抽中「${selectedName}」，請先按「抽紅包（第二輪）」`;
        secondBtn.style.display = "inline-block";
        secondBtn.classList.add("blinking");
    }
})();

/* ==================================
   畫輪盤（使用 rotationOffset）
   幾何設定：
   - slice i 起始角度：start = -π/2 - arc/2 + i*arc
   - slice i 中心角度：center = -π/2 + i*arc
   → pointer 固定在 -π/2（正上方），
     當 rotationOffset = -i*arc 時，i 號切片中心正好在指針下方
================================== */
function drawWheel(items, opt = {}){
    const {
        hideText = false,
        highlightWinnerIndex = null,
        highlightVerseText   = ""
    } = opt;

    ctx.clearRect(0,0,380,380);
    if (!items || !items.length) return;

    const count = items.length;
    const arc   = 2 * Math.PI / count;

    ctx.save();
    ctx.translate(CENTER, CENTER);
    ctx.rotate(rotationOffset);
    ctx.translate(-CENTER, -CENTER);

    for (let i=0; i<count; i++){
        const start = -Math.PI/2 - arc/2 + i*arc;
        const end   = start + arc;

        // 扇形背景
        ctx.beginPath();
        ctx.moveTo(CENTER, CENTER);
        ctx.arc(CENTER, CENTER, RADIUS, start, end);
        ctx.closePath();
        ctx.fillStyle = (i % 2 === 0) ? "#fde7b5" : "#fcdca0";
        ctx.fill();

        // 白色分隔線
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.stroke();

        // 姓名（若不隱藏）
        if (!hideText){
            const centerAngle = -Math.PI/2 + i*arc;
            ctx.save();
            ctx.translate(CENTER, CENTER);
            ctx.rotate(centerAngle);
            ctx.textAlign = "right";
            ctx.font = "22px Noto Sans TC";
            ctx.fillStyle = "#5b3a00";
            ctx.fillText(items[i], RADIUS - 22, 10);
            ctx.restore();
        }
    }

    // 第二輪：只在中獎格畫上經句編號
    if (highlightWinnerIndex != null && highlightVerseText){
        const centerAngle = -Math.PI/2 + highlightWinnerIndex*arc;
        ctx.save();
        ctx.translate(CENTER, CENTER);
        ctx.rotate(centerAngle);
        ctx.textAlign = "right";
        ctx.font = "24px Noto Sans TC";
        ctx.fillStyle = "#b03a00";
        ctx.fillText(highlightVerseText, RADIUS - 40, 10);
        ctx.restore();
    }

    ctx.restore();
}

/* ==================================
   緩動函數（自然減速）
================================== */
function easeOutCubic(t){
    return 1 - Math.pow(1 - t, 3);
}

/* ==================================
   核心：轉盤動畫（自然停點 + 精準命中）
   items    : 名單
   index    : 要命中的 index（0 ~ N-1）
   clockwise: true = 順時針、false = 逆時針
   options  : { hideText, highlightWinnerIndex, highlightVerseText }
================================== */
function spinToIndex(items, index, clockwise, options = {}){
    return new Promise(resolve => {
        if (!items || !items.length){
            resolve();
            return;
        }
        const count = items.length;
        const arc   = 2 * Math.PI / count;

        // 目標：rotationOffset_f = - index * arc
        const baseTarget = -index * arc;

        // 自然旋轉 4~6 圈
        const spins     = 4 + Math.random() * 2;
        const direction = clockwise ? 1 : -1;

        const startAngle = rotationOffset;
        const endAngle   = baseTarget + direction * spins * 2 * Math.PI;

        playDrum();

        const startTime  = performance.now();
        const duration   = 5000; // 5 秒

        function frame(now){
            let t = (now - startTime) / duration;
            if (t > 1) t = 1;
            const eased = easeOutCubic(t);
            const current = startAngle + (endAngle - startAngle) * eased;

            rotationOffset = current;
            drawWheel(items, options);

            if (t < 1){
                requestAnimationFrame(frame);
            } else {
                // 將 rotationOffset 歸約到「真正目標 baseTarget」的等價角度
                rotationOffset = baseTarget;
                drawWheel(items, options);
                resolve();
            }
        }

        requestAnimationFrame(frame);
    });
}

/* ==================================
   鎖定名單
================================== */
function lockList(){
    const raw = document.getElementById("nameInput").value.trim();
    if (!raw){
        alert("請先輸入姓名！");
        return;
    }

    const arr = raw.split(/[,、\s]+/)
        .map(s => s.trim())
        .filter(s => s.length > 0);

    if (arr.length < 2){
        alert("至少要兩位姓名才能轉輪盤！");
        return;
    }

    nameList = arr;
    locked   = true;

    usedNames      = [];
    usedVerses     = [];
    roundFinished  = false;
    awaitingSecond = false;
    selectedName   = null;
    selectedVerse  = null;
    selectedTime   = null;
    rotationOffset = 0;

    lsSet("nameList", nameList);
    lsSet("usedNames", []);
    lsSet("usedVerses", []);
    lsSet("roundFinished", false);
    lsSet("awaitingSecond", false);
    lsSet("currentName", null);
    lsSet("currentVerse", null);
    lsSet("currentTime", null);

    statusText.textContent = `名單已鎖定，共 ${nameList.length} 位`;
    startBtn.disabled = false;
    secondBtn.style.display = "none";
    viewerBtn.style.display = "none";
    verseBadge.style.display = "none";

    drawWheel(nameList);
}

/* ==================================
   第一輪：抽姓名（逆時針）
   規則：
   - 若上一位已抽完第 1 輪但尚未抽第 2 輪，禁止重新開始
================================== */
async function startFirstRound(){
    if (roundFinished){
        alert("本輪已完成全部抽籤，請按「全部歸零」。");
        return;
    }
    if (!locked || nameList.length < 2){
        alert("請先輸入姓名並鎖定名單！");
        return;
    }
    if (awaitingSecond && selectedName && !selectedVerse){
        alert("已抽完第 1 輪，請先按「抽紅包（第二輪）」再開始下一位！");
        return;
    }

    const remaining = nameList.filter(n => !usedNames.includes(n));
    if (!remaining.length){
        alert("全部姓名都已完成紅包抽籤！");
        roundFinished = true;
        lsSet("roundFinished", true);
        startBtn.disabled = true;
        return;
    }

    const winner = remaining[Math.floor(Math.random()*remaining.length)];
    const winnerIndex = nameList.indexOf(winner);

    selectedName   = winner;
    selectedVerse  = null;
    selectedTime   = null;
    awaitingSecond = true;

    lsSet("currentName", winner);
    lsSet("currentVerse", null);
    lsSet("currentTime", null);
    lsSet("awaitingSecond", true);

    statusText.textContent = "第 1 輪：姓名輪盤抽籤中…";
    verseBadge.style.display = "none";
    viewerBtn.style.display  = "none";

    // 轉動到中獎者位置（自然停點）
    await spinToIndex(nameList, winnerIndex, false, { hideText:false });

    statusText.textContent = `第 1 輪完成：抽中「${winner}」`;

    setTimeout(() => {
        secondBtn.style.display = "inline-block";
        secondBtn.classList.add("blinking");
    }, 800);
}

/* ==================================
   第二輪：抽經句（順時針）
   - 外觀：仍用同一輪盤，但不顯示姓名（空白切片）
   - 指針仍停在第 1 輪同一格
   - 內部：從 001–128 未抽過的經句中抽一個
================================== */
async function startSecondRound(){
    secondBtn.classList.remove("blinking");
    secondBtn.style.display = "none";

    if (!selectedName){
        alert("請先完成第一輪抽姓名！");
        return;
    }

    const verseNums = Object.keys(window.VERSE_REF_MAP || {});
    if (!verseNums.length){
        alert("找不到經句對照表（VERSE_REF_MAP）！");
        return;
    }

    const available = verseNums.filter(v => !usedVerses.includes(v));
    if (!available.length){
        alert("128 篇經句都已經抽完了！");
        return;
    }

    statusText.textContent = "第 2 輪：祝福經句輪盤抽籤中…";
    verseBadge.style.display = "none";

    const winnerIndex = nameList.indexOf(selectedName);
    if (winnerIndex < 0){
        alert("內部錯誤：找不到中獎姓名的位置。");
        return;
    }

    // 真正抽出經句編號（內部邏輯）
    selectedVerse = available[Math.floor(Math.random()*available.length)];
    usedVerses.push(selectedVerse);
    lsSet("usedVerses", usedVerses);

    // 產生時間戳記
    const now = new Date();
    const ts =
        `${now.getFullYear()}/` +
        `${String(now.getMonth()+1).padStart(2,"0")}/` +
        `${String(now.getDate()).padStart(2,"0")} ` +
        `${String(now.getHours()).padStart(2,"0")}:` +
        `${String(now.getMinutes()).padStart(2,"0")}:` +
        `${String(now.getSeconds()).padStart(2,"0")}`;

    selectedTime = ts;
    lsSet("currentVerse", selectedVerse);
    lsSet("currentTime", selectedTime);

    const ref       = (window.VERSE_REF_MAP || {})[selectedVerse] || "";
    const verseText = `編號「${selectedVerse}」`;

    // 第二輪：同一個 index，再轉一輪（順時針），外觀不顯示姓名，只在中獎格顯示編號
    await spinToIndex(
        nameList,
        winnerIndex,
        true,
        {
            hideText:true,
            highlightWinnerIndex:winnerIndex,
            highlightVerseText:verseText
        }
    );

    verseBadge.textContent = verseText;
    verseBadge.style.display = "block";

    statusText.textContent = `第 2 輪完成：抽中經句「${selectedVerse}」`;

    // 寫入紀錄（兩輪都完成才算）
    saveRecord(selectedName, selectedVerse, selectedTime);

    awaitingSecond = false;
    lsSet("awaitingSecond", false);

    setTimeout(() => {
        viewerBtn.style.display = "inline-block";
    }, 800);
}

/* ==================================
   儲存抽籤紀錄
================================== */
function saveRecord(name, verse, timeStr){
    const ref = (window.VERSE_REF_MAP || {})[verse] || "";
    let logs = lsGet("drawLogs", []);
    logs.push({
        time: timeStr,
        mode: "姓名模式",
        name,
        verse,
        ref
    });
    lsSet("drawLogs", logs);

    if (!usedNames.includes(name)){
        usedNames.push(name);
        lsSet("usedNames", usedNames);
    }

    if (usedNames.length >= nameList.length){
        roundFinished = true;
        lsSet("roundFinished", true);
        startBtn.disabled = true;
    }
}

/* ==================================
   前往 viewer.html（帶 name, verse, time）
================================== */
function gotoViewer(){
    if (!selectedName || !selectedVerse){
        alert("請先完成兩輪抽籤！");
        return;
    }
    const url =
        `viewer.html?name=${encodeURIComponent(selectedName)}` +
        `&verse=${encodeURIComponent(selectedVerse)}` +
        `&time=${encodeURIComponent(selectedTime || "")}`;
    window.location.href = url;
}

/* ==================================
   全部歸零
================================== */
function resetAll(){
    if (!confirm("確定要清除目前這一輪的所有資料嗎？")) return;
    Object.keys(localStorage)
        .filter(k => k.startsWith(LS_PREFIX))
        .forEach(k => localStorage.removeItem(k));
    alert("所有資料已清空！");
    location.reload();
}

/* ==================================
   PDF 匯出（外部字型：思源黑體）
================================== */
async function exportPDF(){
    let logs = lsGet("drawLogs", []);
    if (!logs.length){
        alert("目前尚無抽籤紀錄！");
        return;
    }

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit:"pt", format:"a4" });

    // 載入外部字型
    let fontData;
    try{
        const res = await fetch("fonts/SourceHanSansTC-Regular.ttf");
        const buf = await res.arrayBuffer();
        const bytes = new Uint8Array(buf);
        let binary = "";
        for (let i=0;i<bytes.length;i++){
            binary += String.fromCharCode(bytes[i]);
        }
        fontData = btoa(binary);
    }catch(e){
        console.error(e);
        alert("無法載入字型 fonts/SourceHanSansTC-Regular.ttf，請確認檔案存在。");
        return;
    }

    doc.addFileToVFS("SourceHanSansTC-Regular.ttf", fontData);
    doc.addFont("SourceHanSansTC-Regular.ttf", "SourceHanTC", "normal");
    doc.setFont("SourceHanTC", "normal");

    doc.setFontSize(18);
    doc.text("BlessingCards128 抽籤紀錄", 40, 40);

    let y = 70;
    doc.setFontSize(13);

    logs.forEach(log => {
        const line =
            `[${log.time}] ${log.name}｜${log.mode} 抽中經句：${log.verse}` +
            (log.ref ? `（${log.ref}）` : "");
        doc.text(line, 40, y);
        y += 22;
        if (y > 780){
            doc.addPage();
            y = 60;
        }
    });

    doc.save("BlessingCards128_抽籤紀錄.pdf");
}
</script>
</body>
</html>
