<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>BlessingCards128 Host (Stable Single-File)</title>
  <style>
    :root{
      --bg:#f6f0e6; --card:#fff; --muted:#6b7280;
      --shadow: 0 6px 24px rgba(0,0,0,.08); --r:16px;
      --line:3px;
    }
    html,body{margin:0;padding:0;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans TC",sans-serif;color:#111827}
    .wrap{max-width:1100px;margin:0 auto;padding:16px}
    .card{background:var(--card);border-radius:var(--r);box-shadow:var(--shadow);padding:14px}
    .topbar{display:flex;gap:12px;align-items:center}
    .topbar img{width:44px;height:44px;border-radius:10px;object-fit:cover}
    .big{font-size:18px;font-weight:800}
    .muted{color:var(--muted);font-size:13px}
    .grid{display:grid;grid-template-columns: 1.2fr .8fr; gap:14px}
    @media (max-width: 860px){ .grid{grid-template-columns:1fr} }
    h1{font-size:16px;margin:0 0 10px}

    textarea{width:100%;min-height:84px;resize:vertical;border:1px solid #e5e7eb;border-radius:12px;padding:10px;font-size:14px}
    textarea:disabled{background:#f9fafb;color:#6b7280}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    button{border:0;border-radius:12px;padding:10px 12px;font-weight:800;cursor:pointer;box-shadow:0 2px 10px rgba(0,0,0,.06)}
    button:disabled{opacity:.35;cursor:not-allowed;box-shadow:none}
    .secondary{background:#f3f4f6}
    .blue{background:#93c5fd}
    .danger{background:#fca5a5}
    .pill{display:inline-flex;align-items:center;gap:6px;border:1px solid #e5e7eb;border-radius:999px;padding:6px 10px;font-size:12px;background:#fff}
    .status{font-size:14px;font-weight:900}
    .canvasWrap{margin-top:12px;background:#fff;border-radius:var(--r);box-shadow:var(--shadow);padding:12px}
    canvas{display:block;width:100%;max-width:520px;height:auto;margin:0 auto}
    .qrBox img{width:220px;height:220px;display:block;margin:0 auto;border-radius:12px;background:#fff}
    .logBox{margin-top:12px}
    .logBox pre{margin:0;background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:10px;white-space:pre-wrap;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px}
    .ok{color:#059669}
    .warn{color:#b45309}
    .hint3{white-space:pre-line}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="topbar">
        <img src="../logo3524.png" alt="logo" onerror="this.style.display='none'">
        <div>
          <div class="big">ç¥ç¦ç¶“å¥ç´…åŒ…ï¼ˆä¸»æŒæ©Ÿï½œStable å–®æª”ï¼‰</div>
          <div class="muted">QR å›ºå®šå…¥å£ï½œViewer è‡ªå‹•æ›´æ–°ï½œä¸æ‹†æ¨¡çµ„</div>
        </div>
      </div>
    </div>

    <div class="grid" style="margin-top:14px">
      <div class="card">
        <h1>æ“ä½œ</h1>

        <div class="row" style="margin-bottom:10px">
          <span class="pill">ç‹€æ…‹ï¼š<span id="sysPill">INIT</span></span>
          <span class="pill">æœ¬è¼ªï¼š<span id="idxPill">0/0</span></span>
          <span class="pill">ç›®å‰ï¼š<span id="curPill">-</span></span>
        </div>

        <label class="muted">è¼¸å…¥å§“åï¼ˆå¯ç”¨ç©ºç™½ / é€—è™Ÿ / æ›è¡Œåˆ†éš”ï¼‰</label>
        <textarea id="nameInput"
          placeholder="ä¾‹å¦‚ï¼šå°æ˜ å°è¯ å°ç¾"
          autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"></textarea>

        <div class="row" style="margin-top:10px">
          <button id="btnLock">é–å®šåå–®</button>
          <button id="btnRound1" class="secondary">é–‹å§‹æŠ½å§“åï¼ˆç¬¬ä¸€è¼ªï¼‰</button>
          <button id="btnRound2" class="secondary">æŠ½ç´…åŒ…ï¼ˆç¬¬äºŒè¼ªï¼‰</button>
          <button id="btnView" class="blue">çœ‹ç´…åŒ…ï¼ˆé–‹ Viewerï¼‰</button>
        </div>

        <div class="row" style="margin-top:10px">
          <button id="btnNext" class="secondary">ä¸‹ä¸€ä½</button>
          <button id="btnPdf" class="blue">æŠ½ç±¤ç´€éŒ„ PDF</button>
          <button id="btnReset" class="danger">å…¨éƒ¨æ­¸é›¶</button>
        </div>

        <div style="margin-top:12px">
          <div class="status" id="statusLine">ç³»çµ±åˆå§‹åŒ–ä¸­â€¦</div>
          <div class="muted hint3" id="centerLine" style="margin-top:6px"></div>
        </div>

        <div class="canvasWrap">
          <canvas id="wheelCanvas" width="900" height="900"></canvas>
        </div>

        <div class="logBox">
          <div class="muted" style="margin:8px 0 6px">æŠ½ç±¤ç´€éŒ„ï¼ˆæœ€æ–°åœ¨ä¸‹ï¼‰</div>
          <pre id="logPre">(å°šç„¡)</pre>
        </div>
      </div>

      <div class="card">
        <h1>QRï¼ˆåƒèˆ‡è€…åªè®€ Viewerï¼‰</h1>
        <div class="qrBox">
          <img id="qrImg" alt="QR" />
        </div>
        <div class="muted" style="margin-top:10px">
          åƒèˆ‡è€…æƒæå¾Œæœƒè‡ªå‹•æ›´æ–°é¡¯ç¤ºã€Œæœ€æ–°æŠ½åˆ°çš„ç´…åŒ…ã€ã€‚
        </div>
        <div class="row" style="margin-top:10px">
          <button id="btnCopy" class="secondary">è¤‡è£½</button>
        </div>
        <input id="qrUrl" style="width:100%;margin-top:10px;border:1px solid #e5e7eb;border-radius:12px;padding:10px" readonly />
      </div>
    </div>
  </div>

  <audio id="drum" src="../audio/drum.mp3" preload="auto"></audio>
  <audio id="winSound" src="../audio/win.mp3" preload="auto"></audio>

  <script src="../verseRefMap.js"></script>
  <script>
    // ==========================
    // Stable Single-File Host
    // ==========================

    const KEY = "BC_STABLE_V1";
    const LAST_VERSE_KEY = "LAST_VERSE";
    const LAST_UPDATE_KEY = "LAST_UPDATE";

    const SYS = Object.freeze({
      INIT: "INIT",
      ROUND1_READY: "ROUND1_READY",
      ROUND1_SPIN: "ROUND1_SPIN",
      ROUND2_READY: "ROUND2_READY",
      ROUND2_SPIN: "ROUND2_SPIN",
      VIEWER_READY: "VIEWER_READY",
      FINISHED: "FINISHED",
    });

    const $ = (id) => document.getElementById(id);

    function nowHHMMSS(){
      const d = new Date();
      const hh = String(d.getHours()).padStart(2,"0");
      const mm = String(d.getMinutes()).padStart(2,"0");
      const ss = String(d.getSeconds()).padStart(2,"0");
      return `${hh}:${mm}:${ss}`;
    }

    function pad3(n){
      const s = String(n);
      return s.length >= 3 ? s : ("000"+s).slice(-3);
    }

    function getRef(code3){
      const m = window.verseRefMap || {};
      return m[code3] || "";
    }

    function parseNames(raw){
      const tokens = String(raw||"")
        .split(/[\n,ï¼Œ\s]+/g)
        .map(s => s.trim())
        .filter(Boolean);

      const seen = new Set();
      const out = [];
      let hasDup = false;

      for (const t of tokens){
        if (seen.has(t)) { hasDup = true; continue; }
        seen.add(t);
        out.push(t);
      }
      return { list: out, hasDup };
    }

    function defaultState(){
      return {
        system: SYS.INIT,
        names: [],
        usedIdx: [],          // indices of names already done (after ROUND1)
        verseUsed: [],        // codes "001".."128"
        curIdx: -1,           // current winner index (after ROUND1)
        curVerse: null,       // {code, ref}
        logs: []              // {t,name,code,ref}
      };
    }

    function loadState(){
      try{
        const raw = localStorage.getItem(KEY);
        if (!raw) return defaultState();
        const s = JSON.parse(raw);
        const d = defaultState();
        for (const k of Object.keys(d)){
          if (!(k in s)) s[k] = d[k];
        }
        if (!Array.isArray(s.names)) s.names = [];
        if (!Array.isArray(s.usedIdx)) s.usedIdx = [];
        if (!Array.isArray(s.verseUsed)) s.verseUsed = [];
        if (!Array.isArray(s.logs)) s.logs = [];
        if (typeof s.curIdx !== "number") s.curIdx = -1;
        if (s.curVerse && typeof s.curVerse !== "object") s.curVerse = null;
        if (!Object.values(SYS).includes(s.system)) s.system = SYS.INIT;
        return s;
      }catch{
        return defaultState();
      }
    }

    function saveState(){
      try{ localStorage.setItem(KEY, JSON.stringify(state)); }catch{}
    }

    function clearAllStorage(){
      try{ localStorage.removeItem(KEY); }catch{}
      try{ localStorage.removeItem(LAST_VERSE_KEY); }catch{}
      try{ localStorage.removeItem(LAST_UPDATE_KEY); }catch{}
    }

    // Global
    let state = loadState();

    // --------------------------
    // Canvas / Wheel
    // --------------------------
    const canvas = $("wheelCanvas");
    const ctx = canvas.getContext("2d");

    // Visual spec
    const LINE_W = 3;                // outer + segment line width = 3px
    const RAY_W  = 3;                // inner-cut line width = 3px
    const RAY_COLOR = "#ffffff";     // inner-cut line is white
    const POINTER_ANGLE = -Math.PI/2; // 12 o'clock

    let rotation = 0;
    let spinning = false;
    let highlightIdx = null; // index in names to highlight (è´´é½æ‰‡å½¢), null means none

    function clear(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }

    function drawBaseCircle(cx, cy, R){
      // single circle + inner cut line
      ctx.save();
      ctx.translate(cx,cy);

      // circle
      ctx.beginPath();
      ctx.arc(0,0,R,0,Math.PI*2);
      ctx.lineWidth = LINE_W;
      ctx.strokeStyle = "#111827";
      ctx.stroke();

      // inner ray line (3px white)
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(Math.cos(POINTER_ANGLE)*R, Math.sin(POINTER_ANGLE)*R);
      ctx.lineWidth = RAY_W;
      ctx.strokeStyle = RAY_COLOR;
      ctx.stroke();

      ctx.restore();
    }

    function drawWheel(){
      clear();

      const W = canvas.width, H = canvas.height;
      const cx = W/2, cy = H/2;
      const R  = Math.min(W,H) * 0.46;

      // INIT: single circle
      if (!state.names || state.names.length === 0){
        drawBaseCircle(cx,cy,R);
        return;
      }

      const N = state.names.length;
      const step = (Math.PI*2)/N;

      ctx.save();
      ctx.translate(cx,cy);

      // rotate wheel only (pointer/ray stays fixed later)
      ctx.rotate(rotation);

      // slices
      for (let i=0;i<N;i++){
        const a0 = i*step;
        const a1 = a0 + step;

        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0,R,a0,a1);
        ctx.closePath();

        // fill
        ctx.fillStyle = (i%2===0) ? "#f5c64d" : "#f7dea2";
        ctx.fill();

        // segment border (3px)
        ctx.lineWidth = LINE_W;
        ctx.strokeStyle = "#111827";
        ctx.stroke();

        // label (name)
        const mid = a0 + step/2;
        ctx.save();
        ctx.rotate(mid);
        ctx.textAlign = "right";
        ctx.fillStyle = "#111827";
        ctx.font = "26px Noto Sans TC, system-ui";
        ctx.fillText(String(state.names[i]), R-14, 10);
        ctx.restore();
      }

      // highlight sector (NO stroke,è´´é½æ‰‡å½¢ï¼Œæ— å¤–æ¡†)
      if (highlightIdx !== null && highlightIdx >= 0 && highlightIdx < N){
        const a0 = highlightIdx*step;
        const a1 = a0 + step;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0,R,a0,a1);
        ctx.closePath();
        ctx.fillStyle = "rgba(255,255,255,0.32)";
        ctx.fill();
      }

      // outer border (3px) - draw once more to keep crisp
      ctx.beginPath();
      ctx.arc(0,0,R,0,Math.PI*2);
      ctx.lineWidth = LINE_W;
      ctx.strokeStyle = "#111827";
      ctx.stroke();

      ctx.restore();

      // fixed inner ray (3px white) as pointer/cut line
      ctx.save();
      ctx.translate(cx,cy);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(Math.cos(POINTER_ANGLE)*R, Math.sin(POINTER_ANGLE)*R);
      ctx.lineWidth = RAY_W;
      ctx.strokeStyle = RAY_COLOR;
      ctx.stroke();
      ctx.restore();
    }

    function angleForIndexAtPointer(idx, N){
      // We want the center of idx slice to align with pointer at 12 o'clock.
      const step = (Math.PI*2)/N;
      const mid = idx*step + step/2;
      // wheel rotation to bring 'mid' to POINTER_ANGLE
      return POINTER_ANGLE - mid;
    }

    function easeOutCubic(t){ return 1 - Math.pow(1-t,3); }

    function spinToIndex(targetIdx, direction, durationMs){
      return new Promise((resolve) => {
        const N = state.names.length;
        const targetRot = angleForIndexAtPointer(targetIdx, N);

        const startRot = rotation;
        const baseDelta = (direction >= 0 ? 1 : -1) * (Math.PI*2) * (6 + Math.random()*2); // 6~8åœˆ
        // add the exact landing adjustment
        const landingDelta = ((targetRot - startRot) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);
        const endRot = startRot + baseDelta + (direction >= 0 ? landingDelta : -landingDelta);

        const t0 = performance.now();
        spinning = true;

        function frame(now){
          const t = Math.min(1, (now - t0) / durationMs);
          const k = easeOutCubic(t);
          rotation = startRot + (endRot - startRot) * k;
          drawWheel();
          if (t < 1){
            requestAnimationFrame(frame);
          } else {
            spinning = false;
            // snap to exact target for perfect alignment (noåå·®)
            rotation = targetRot;
            drawWheel();
            resolve();
          }
        }
        requestAnimationFrame(frame);
      });
    }

    // --------------------------
    // Logic helpers
    // --------------------------
    function usedSet(){
      return new Set(state.usedIdx || []);
    }
    function remainingIndices(){
      const used = usedSet();
      const out = [];
      for (let i=0;i<(state.names||[]).length;i++){
        if (!used.has(i)) out.push(i);
      }
      return out;
    }
    function remainingVerses(){
      const used = new Set(state.verseUsed || []);
      const out = [];
      for (let i=1;i<=128;i++){
        const c = pad3(i);
        if (!used.has(c)) out.push(c);
      }
      return out;
    }

    function setSys(s){ state.system = s; saveState(); }
    function setStatusOnlySpin(isSpin){
      // æ—‹è½‰æ™‚å”¯ä¸€é¡¯ç¤ºã€Œæ—‹è½‰ä¸­â€¦â€¦ã€
      if (isSpin){
        $("statusLine").textContent = "æ—‹è½‰ä¸­â€¦â€¦";
        $("centerLine").textContent = "";
      }
    }

    function setStatusNormal(text, centerText=""){
      $("statusLine").textContent = text;
      $("centerLine").textContent = centerText;
    }

    function renderLogs(){
      const pre = $("logPre");
      const logs = state.logs || [];
      if (!logs.length){ pre.textContent = "(å°šç„¡)"; return; }
      pre.textContent = logs.map(r => `[${r.t}] ${r.name} -> ${r.code} | ${r.ref}`).join("\n");
    }

    function updateTopPills(){
      $("sysPill").textContent = state.system;
      const total = (state.names||[]).length;
      const done = new Set(state.usedIdx||[]).size;
      $("idxPill").textContent = `${done}/${total}`;
      let curName = "-";
if (
  state.curIdx >= 0 &&
  state.names &&
  state.names[state.curIdx]
){
  curName = state.names[state.curIdx];
}
      $("curPill").textContent = curName;
    }

    function updateButtons(){
      const hasNames = (state.names||[]).length > 0;

      // input enable rules:
      // - INIT: editable
      // - FINISHED: editable (for next round)
      // - else: locked (to prevent accidental change mid-round)
      const inputEditable = (state.system === SYS.INIT || state.system === SYS.FINISHED);
      $("nameInput").disabled = !inputEditable;

      // Lock button enabled in INIT and FINISHED (new round)
      $("btnLock").disabled = !(state.system === SYS.INIT || state.system === SYS.FINISHED);

      // Round1 enabled only when ready and there are remaining
      const r1Ready = (state.system === SYS.ROUND1_READY);
      $("btnRound1").disabled = !(r1Ready && hasNames && remainingIndices().length>0 && !spinning);

      // Round2 enabled only when ready
      const r2Ready = (state.system === SYS.ROUND2_READY);
      $("btnRound2").disabled = !(r2Ready && hasNames && state.curIdx>=0 && !spinning);

      // View enabled only after round2 done for current person
      $("btnView").disabled = !(state.system === SYS.VIEWER_READY && state.curVerse);

      // Next enabled after round2 done, and if not finished
      $("btnNext").disabled = !(state.system === SYS.VIEWER_READY && !spinning);

      // PDF enabled when there is at least 1 log
      $("btnPdf").disabled = !((state.logs||[]).length>0);

      // Reset always enabled
      $("btnReset").disabled = false;
    }

    function refreshUI(){
      updateTopPills();
      renderLogs();
      updateButtons();
    }

    // --------------------------
    // QR (fixed) + copy
    // --------------------------
    function viewerUrl(){
      // host/index.html -> host/viewer.html
      return location.origin + location.pathname.replace(/\/index\.html$/,"/viewer.html");
    }
    function updateQR(){
      const url = viewerUrl();
      $("qrUrl").value = url;
      $("qrImg").src = "https://api.qrserver.com/v1/create-qr-code/?size=220x220&data=" + encodeURIComponent(url);
    }

    async function copyQRUrl(){
      const url = $("qrUrl").value || viewerUrl();
      try{
        await navigator.clipboard.writeText(url);
        $("btnCopy").textContent = "å·²è¤‡è£½";
        setTimeout(()=> $("btnCopy").textContent = "è¤‡è£½", 900);
      }catch{
        // fallback
        $("qrUrl").select();
        document.execCommand("copy");
        $("btnCopy").textContent = "å·²è¤‡è£½";
        setTimeout(()=> $("btnCopy").textContent = "è¤‡è£½", 900);
      }
    }

    // --------------------------
    // Audio
    // --------------------------
    function stopAudio(){
      const drum = $("drum");
      const win  = $("winSound");
      try{ drum.pause(); drum.currentTime=0; }catch{}
      try{ win.pause();  win.currentTime=0; }catch{}
    }

    function playDrum(){
      const drum = $("drum");
      try{ drum.pause(); drum.currentTime=0; }catch{}
      drum.play().catch(()=>{});
    }

    function playWinAt7s(){
      const drum = $("drum");
      const win  = $("winSound");
      let fired = false;

      function loop(){
        if (!fired && drum.currentTime >= 7){
          fired = true;
          win.currentTime = 0;
          win.volume = 1;
          win.play().catch(()=>{});
        }
        if (drum.currentTime < 11){
          requestAnimationFrame(loop);
        }
      }
      requestAnimationFrame(loop);
    }

    // --------------------------
    // PDF (whole logs) via print
    // --------------------------
    function openPdfPrint(){
      const logs = state.logs || [];
      if (!logs.length) return;

      const title = "BlessingCards128 æŠ½ç±¤ç´€éŒ„";
      const rows = logs.map(r => `
        <tr>
          <td>${escapeHtml(r.t)}</td>
          <td>${escapeHtml(r.name)}</td>
          <td>${escapeHtml(r.code)}</td>
          <td>${escapeHtml(r.ref)}</td>
        </tr>
      `).join("");

      const html = `<!doctype html><html><head>
        <meta charset="utf-8"/>
        <title>${title}</title>
        <style>
          body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans TC",sans-serif;padding:24px;}
          h1{font-size:20px;margin:0 0 12px;}
          table{border-collapse:collapse;width:100%;}
          th,td{border:1px solid #ccc;padding:8px;font-size:14px;text-align:left;}
          th{background:#f3f4f6;}
        </style>
      </head><body>
        <h1>${title}</h1>
        <table>
          <thead>
            <tr><th>æ™‚é–“</th><th>å§“å</th><th>ç¶“å¥ä»£è™Ÿ</th><th>ç« ç¯€</th></tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
        <script>window.onload=function(){window.print();}<\/script>
      </body></html>`;

      const w = window.open("", "_blank", "noopener,noreferrer");
      if (!w) return;
      w.document.open();
      w.document.write(html);
      w.document.close();
    }

    function escapeHtml(s){
      return String(s||"")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#39;");
    }

    // --------------------------
    // Core flows (match your guarantees)
    // --------------------------

    function showFinishedHint(){
      const total = (state.names||[]).length;
      const lines =
`ğŸ‰ æ­¤è¼ªè½‰ç›¤å·²å®Œæˆ ${total} ä½çš„ç´…åŒ…æŠ½ç±¤
ğŸ“„ è«‹æŒ‰ã€ŒæŠ½ç±¤ç´€éŒ„ PDFã€ä¸‹è¼‰ç´€éŒ„ï¼Œæˆ–
ğŸ” è¼¸å…¥æ–°å§“å â†’ æŒ‰ã€Œé–å®šåå–®ã€é–‹å§‹ä¸‹ä¸€è¼ªï¼›ä¹Ÿå¯æŒ‰ã€Œå…¨éƒ¨æ­¸é›¶ã€`;
      setStatusNormal("æœ¬è¼ªå·²å®Œæˆ", lines);
    }

    function shouldForceNewRoundOnLock(){
      // é˜²å‘†ï¼šç•¶å…¨éƒ¨æŠ½å®Œå¾Œï¼Œä½¿ç”¨è€…ç›´æ¥æ”¹åå–®æŒ‰é–å®šï¼Œå¿…é ˆå›åˆ°åŸå§‹ç‹€æ…‹ï¼ˆæ–°å±€ï¼‰
      // å¦å¤–ï¼šè‹¥æ®˜ç•™ usedIdx / verseUsed / logs / curVerse éƒ½è¦–ç‚ºèˆŠå±€æ±¡æŸ“ -> æ–°å±€
      if (state.system === SYS.FINISHED) return true;
      if ((state.usedIdx||[]).length > 0) return true;
      if ((state.verseUsed||[]).length > 0) return true;
      if ((state.logs||[]).length > 0) return true;
      if (state.curVerse) return true;
      if (state.curIdx >= 0) return true;
      return false;
    }

    function hardResetToInit(){
      stopAudio();
      state = defaultState();
      rotation = 0;
      highlightIdx = null;
      spinning = false;
      clearAllStorage();
      saveState();
      drawWheel();
      setStatusNormal("è«‹è¼¸å…¥å§“åä¸¦é–å®šåå–®", "");
      refreshUI();
    }

    async function onLock(){
      if (spinning) return;

      // é˜²å›å¡«ï¼šæœªé–å®šæ™‚ä¿æŒæ¸…ç©ºï¼ˆé¿å… 1 2 3ï¼‰
      const ni = $("nameInput");
      ni.setAttribute("autocomplete","off");

      const raw = ni.value || "";
      const { list, hasDup } = parseNames(raw);

      if (hasDup){
        alert("Oops, æœ‰å§“åé‡è¤‡è¼¸å…¥äº†å”·!");
        return;
      }
      if (!list.length){
        alert("è«‹å…ˆè¼¸å…¥è‡³å°‘ 1 å€‹å§“å");
        return;
      }

      // å¼·åˆ¶æ–°å±€ï¼ˆç¬¦åˆä½ çš„é˜²å‘†è¦æ ¼ï¼‰
      if (shouldForceNewRoundOnLock()){
        state = defaultState();
        rotation = 0;
        highlightIdx = null;
        spinning = false;
        // æ¸…æ‰èˆŠ viewer èˆ‡æ›´æ–°æˆ³
        try{ localStorage.removeItem(LAST_VERSE_KEY); }catch{}
        try{ localStorage.removeItem(LAST_UPDATE_KEY); }catch{}
      }

      state.names = list;
      state.usedIdx = [];
      state.verseUsed = [];
      state.curIdx = -1;
      state.curVerse = null;
      state.logs = [];

      setSys(SYS.ROUND1_READY);
      saveState();

      // åˆå§‹é«˜äº®ç„¡
      highlightIdx = null;
      rotation = 0;

      drawWheel();
      setStatusNormal("æº–å‚™æŠ½å§“åï¼ˆç¬¬ä¸€è¼ªï¼‰", "");
      refreshUI();
    }

    async function onRound1(){
      if (spinning) return;
      const remain = remainingIndices();
      if (!remain.length){
        // Should be finished already, but safe:
        setSys(SYS.FINISHED);
        saveState();
        highlightIdx = null;
        drawWheel();
        showFinishedHint();
        refreshUI();
        return;
      }

      setSys(SYS.ROUND1_SPIN);
      saveState();
      setStatusOnlySpin(true);
      refreshUI();

      // pick winner index from remaining
      const targetIdx = remain[Math.floor(Math.random()*remain.length)];

      // During spin, no need to hide highlight if none; but keep as-is per spec.
      // We'll keep highlight off during spin to prevent "æ®˜å½±" perception.
      const prevHighlight = highlightIdx;
      highlightIdx = null;
      drawWheel();

      // audio for round1 (drum)
      stopAudio();
      playDrum();

      // spin forward to target
      await spinToIndex(targetIdx, +1, 10000);

      // highlightè´´é½æ‰‡å½¢
      highlightIdx = targetIdx;

      // set current winner
      state.curIdx = targetIdx;
      if (!Array.isArray(state.usedIdx)) state.usedIdx = [];
      const used = new Set(state.usedIdx);
      used.add(targetIdx);
      state.usedIdx = Array.from(used);

      setSys(SYS.ROUND2_READY);
      saveState();

      drawWheel();
      setStatusNormal(`ç¬¬ä¸€è¼ªå®Œæˆï¼šæŠ½ä¸­ã€Œ${state.names[targetIdx]}ã€`, "");
      refreshUI();
    }

    async function onRound2(){
      if (spinning) return;
      if (
  state.curIdx < 0 ||
  !state.names ||
  !state.names[state.curIdx]
) return;

      setSys(SYS.ROUND2_SPIN);
      saveState();

      // spec: ç¬¬äºŒè¼ªå‹•ç•«æ™‚æš«æ™‚å–æ¶ˆé«˜äº®ï¼ŒçµæŸå¾Œå›å¾©
      const restoreIdx = state.curIdx;
      highlightIdx = null;
      drawWheel();

      setStatusOnlySpin(true);
      refreshUI();

      stopAudio();
      playDrum();
      playWinAt7s();

      // pick verse from remaining (æŠ½å–æ± ç¨ç«‹ï¼Œä¸å½±éŸ¿ UI æ ¼æ•¸)
      const verses = remainingVerses();
      if (!verses.length){
        // no verses left, treat as finished
        highlightIdx = restoreIdx;
        setSys(SYS.VIEWER_READY);
        saveState();
        drawWheel();
        setStatusNormal("ç¬¬äºŒè¼ªå®Œæˆï¼šç¶“å¥å·²ç”¨ç›¡", "");
        refreshUI();
        return;
      }
      const code = verses[Math.floor(Math.random()*verses.length)];
      const ref  = getRef(code);

      // spin reverse BUT land on the SAME person slice (names displayed)
      await spinToIndex(restoreIdx, -1, 10000);

      // restore highlight
      highlightIdx = restoreIdx;

      // commit verse
      const usedV = new Set(state.verseUsed || []);
      usedV.add(code);
      state.verseUsed = Array.from(usedV);

      state.curVerse = { code, ref };

      // write for viewer (auto-update)
      try{
        localStorage.setItem(LAST_VERSE_KEY, code);
        localStorage.setItem(LAST_UPDATE_KEY, String(Date.now()));
      }catch{}

      // log
      state.logs = state.logs || [];
      state.logs.push({
        t: nowHHMMSS(),
        name: state.names[restoreIdx],
        code,
        ref
      });

      // After round2 complete: VIEWER_READY
      setSys(SYS.VIEWER_READY);
      saveState();

      drawWheel();
      setStatusNormal(`ç¬¬äºŒè¼ªå®Œæˆï¼šæŠ½ä¸­ç¶“å¥ã€Œ${code}ã€`, ref ? `ç« ç¯€ï¼š${ref}` : "");
      refreshUI();

      // If this was the LAST person: immediate enable PDF + Lock (new round)
      const done = new Set(state.usedIdx || []).size;
      const total = (state.names||[]).length;
      if (total > 0 && done >= total){
        setSys(SYS.FINISHED);
        saveState();
        showFinishedHint();
        // In FINISHED: enable Lock + name input (no reset required)
        refreshUI();
      }
    }

    function onView(){
      if (!state.curVerse) return;
      // MUST NOT auto jump viewer; only open on button.
      const url = viewerUrl();
      window.open(url, "_blank", "noopener,noreferrer");
    }

    function onNext(){
      if (spinning) return;

      // After viewing, proceed to next person if any remain
      const remain = remainingIndices();
      if (!remain.length){
        setSys(SYS.FINISHED);
        saveState();
        showFinishedHint();
        refreshUI();
        return;
      }

      // clear current verse, keep wheel as names, keep highlight cleared until next round1 result
      state.curVerse = null;
      state.curIdx = -1;
      saveState();

      highlightIdx = null;
      drawWheel();

      setSys(SYS.ROUND1_READY);
      saveState();

      setStatusNormal("æº–å‚™æŠ½å§“åï¼ˆç¬¬ä¸€è¼ªï¼‰", "");
      refreshUI();
    }

    function onReset(){
      hardResetToInit();
      // Clear input box explicitly
      const ni = $("nameInput");
      if (ni) ni.value = "";
    }

    // --------------------------
    // Wire events
    // --------------------------
    function wire(){
      $("btnLock").onclick = onLock;
      $("btnRound1").onclick = onRound1;
      $("btnRound2").onclick = onRound2;
      $("btnView").onclick = onView;
      $("btnNext").onclick = onNext;
      $("btnPdf").onclick = openPdfPrint;
      $("btnReset").onclick = onReset;
      $("btnCopy").onclick = copyQRUrl;
    }

    // --------------------------
    // Boot
    // --------------------------
    function boot(){
      updateQR();
      wire();

      // If INIT, enforce empty input to avoid browser auto-fill (1 2 3)
      if (state.system === SYS.INIT){
        $("nameInput").value = "";
      }

      // Restore highlight on reload:
      // - If ROUND2_READY / VIEWER_READY: highlight current person
      if (state.names && state.names.length){
        if (state.curIdx >= 0 && state.curIdx < state.names.length){
          // highlight only when not spinning, and not in INIT
          highlightIdx = (state.system === SYS.ROUND2_READY || state.system === SYS.VIEWER_READY || state.system === SYS.ROUND2_SPIN || state.system === SYS.FINISHED)
            ? state.curIdx
            : null;
        } else {
          highlightIdx = null;
        }
      } else {
        highlightIdx = null;
      }

      // Render based on state
      rotation = rotation || 0;
      drawWheel();

// Show appropriate status
if (state.system === SYS.INIT){
  setStatusNormal("è«‹è¼¸å…¥å§“åä¸¦é–å®šåå–®", "");

} else if (state.system === SYS.ROUND1_READY){
  setStatusNormal("æº–å‚™æŠ½å§“åï¼ˆç¬¬ä¸€è¼ªï¼‰", "");

} else if (state.system === SYS.ROUND2_READY){
  setStatusNormal("è«‹æŠ½ç´…åŒ…ï¼ˆç¬¬äºŒè¼ªï¼‰", "");

} else if (state.system === SYS.VIEWER_READY){

  let t = "ç¬¬äºŒè¼ªå®Œæˆ";
  let c = "";

  if (state.curVerse){
    t = "ç¬¬äºŒè¼ªå®Œæˆï¼šæŠ½ä¸­ç¶“å¥ã€Œ" + state.curVerse.code + "ã€";
    if (state.curVerse.ref){
      c = "ç« ç¯€ï¼š" + state.curVerse.ref;
    }
  }

  setStatusNormal(t, c);

} else if (state.system === SYS.FINISHED){
  showFinishedHint();

} else {

  // If in SPIN state due to reload, normalize to safe ready state
  if ((state.usedIdx||[]).length > 0 && state.curIdx >= 0){
    setSys(SYS.ROUND2_READY);
    setStatusNormal("è«‹æŠ½ç´…åŒ…ï¼ˆç¬¬äºŒè¼ªï¼‰", "");

  } else if (state.names && state.names.length){
    setSys(SYS.ROUND1_READY);
    setStatusNormal("æº–å‚™æŠ½å§“åï¼ˆç¬¬ä¸€è¼ªï¼‰", "");

  } else {
    setSys(SYS.INIT);
    setStatusNormal("è«‹è¼¸å…¥å§“åä¸¦é–å®šåå–®", "");
  }
}

      refreshUI();
      renderLogs();
    }

    window.addEventListener("load", boot);
  </script>
</body>
</html>
